Dimple User Documentation
=======================
:Author:    Shawn Hershey
:Email:     shershey@gmail.com
:Date:      July 27, 
:SW Name: Dimple

Installing {swname}
-----------------

. MATLAB of at least version 2008a is required. 
. Extract the {swname} zip file
. Execute the startup.m script in the resulting {swname} directory to 
load {swname} in MATLAB.
. To avoid having to manually change to this directory and execute 
this script every time you start MATLAB, you will need to add the line:
+ 
run ‘<path-to-{swname}>/startup.m’ 
+
to a startup.m file in MATLAB’s startup.  Google “MATLAB startup.m” for more details regarding startup.m files.

. Verify the installation:
.. Start MATLAB
.. At the MATLAB command prompt type:
test{swname}
//ARG!  I wish I knew how to include ..... in a block literal
.. Verify output is something like: 
+ 
.................. 
=================================================
++test{swname}


Starting test run with 1 test case.
.

PASSED in 0.198 seconds.
Starting test run with 15 test cases.

 ...............
PASSED in 6.460 seconds.



--test{swname}
 ..................

================================================= 
..................

What is {swname}
----------------
{swname} is a tool for rapidly prototyping algorithms that can be described with Factor Graphs and solved with belief propagation algorithms or sampling based algorithms.

{swname} features:

* Runs the sum-product, mi- sum, particle BP, or Gibbs algorithm on a factor graph.
* Supports arbitrary discrete variables.
* Some solvers (Particle BP and Gibbs) support continuous variables.
* Supports arbitrary factor functions.
* Allows rapid prototyping by describing connectivity with simple associations of factors with variables.
* Supports nested graphs.

A Short Introduction to Factor Graphs
-------------------------------------
We introduce factor graphs, a powerful tool for statistical modeling.  
Factor graphs can be used to describe a number of commonly used 
statistical models, such as hidden Markov models, Markov random 
fields, Kalman filters, and Bayes nets. 

Suppose that we are given a set of n discrete random variables:
[latex]
$a_1,...,a_n$

The random variables have some joint probability distribution:
[latex]
\[
p(a_1,a_2,...,a_n)
\]

Suppose that the joint probability distribution factors, in the following sense: there exist subsets 
[latex]
$ S_1,...,S_k \subseteq \lbrace 1,2,...,n\rbrace $

where

[latex]
$ S_j = \lbrace S_1^j,s_2^j,...,s_{t(j)}^j \rbrace $

and such that

[latex]
$ p(a_1,a_2,...,a_n) = \prod_{j=1}^k f_j(a_{s_1^j},a_{s_2^j},...,s_{t(j)}^j) $

For example, if the ai form a Markov chain, then the joint probability can be factored as

[latex]
\begin{eqnarray}
p(a_1,a_2,...,a_n) &=& p(a_1) \prod_{j=1}^{n-1}p(a_{j+1}|a_j) \\
		   &=& f_0(a_1) \prod_{j=1}^{n-1} f_j(a_j,a_{j+1})
\end{eqnarray}

The factors above are normalized, in the sense that as the ai  vary, 
the probabilities sum to one.  We will define our factors more 
generally and ask only that they are proportional to the joint 
probability.  So, we call the fi a collection of factors of p() if 

[latex]
\[
p(a_1,a_2,...,a_n) \propto \prod_{j=1}^k f_j(a_{s_1^j},a_{s_2^j},...,s_{t(j)}^j) 
\]

The product of the factors then differs from the joint probability only by 
multiplication by a normalizing constant.

When a probability distribution can be expressed as a product of small factors 
(i.e. |Sj| is small for all j), then if is possible to invoke a host of powerful 
tools for modeling and inference, as we will soon see.

Suppose that we are given a factored representation of a joint probability distribution.  
It is possible to describe the structure of the factors as a graph.  We can represent 
each variable ai  and each function fj  by a node in the graph, and place an (undirected) 
edge between node ai  and node fj if and only if the variable ai  is an argument in the 
function fj.  These two types of nodes are referred to as function nodes and variable nodes. 
Because all edges lie between the two disjoint classes of nodes, the resulting graph is bipartite.  
This graph is called a factor graph.

In the remainder of this documentation, we slightly abuse notation and use fj  and ai  
to refer both to the nodes of the factor graph and to the underlying factors and variables 
(i.e. both the graphical representation of these entities and the mathematical entities underlying them).

To understand what factor graphs look like, we will construct several examples.  
First, let us continue with a Markov chain. Equation 1 expressed a Markov chain in factored form, where  

[latex]
\[
f_j(a_j,a_{j+1})=p(a_{j+1}|a_j)
\]

We display the corresponding factor graph in the following figure:

image:images/FactorGraphExample.png["alt text",height=100]

Next, let us consider a hidden Markov model (HMM).  We can construct the 
corresponding factor graph by extending the previous example.  An HMM 
contains a Markov chain transiting from state a~i~ to a~i+1~ . There is also an 
observation b~i~  made of each state; if we are given a~i~ , then b~i~  
is conditionally independent of all other variables. We can incorporate 
this probability by using a factor:

[latex]
$ g_i(a_i) = Pr(b_i|a_i) $

The product of our factors is then

[latex]
\begin{eqnarray*}
f_0 \left( \prod_{j=1}^{n-1} f_j(a_j,a_j+1) \right) \prod_{j=1}^n g_j(a_j)  &=& 
    Pr(a_1) \left( \prod_{j=1}^{n-1} Pr(a_{j+1}|a_j)  \right) \prod_{j=1}^n Pr(b_j|a_j)  \\
  &=& Pr(a_1,...,a_n,b_1,...,b_n)
\end{eqnarray*}

Since the b~i~ are observed, then Pr(b~1~,...,b~n~) is a constant.  Therefore

[latex]
\begin{eqnarray*}
Pr(a_1,...,a_n,b_1,...,b_n) & \propto & \frac{a}{b} \\
			    &=& Pr(a_1)
\end{eqnarray*}

Pr(a_1,...,a_n,b_1,...,b_n) & \propto & \frac{Pr(a_1,...,a_n,b_1,...,b_n}{Pr(b_1,...,b_n}
			    &=& Pr(a_1,...,a_n|b_1,...,b_n)

as desired.

image:images/HMMExample.png["alt text",height=200]

The resulting factor graph takes the following form illustrated in the figure above. Note 
that the variables b~i~  need not appear explicitly in the factor graph; we have incorporated their effect in the g~i~  factors.

Generalizing from a Markov chain to an HMM illustrates a very powerful feature of factor graphs.  Complicated mathematical models are often composed of simpler parts.  When these models are expressed as factor graphs, we can frequently reuse the simpler factor graphs to construct the more complicated ones.  This can be done simply in {swname} by using the nested graphs feature (see Nested Graph section).

As a final example, we will construct a factor graph for error correction (for this
 more advanced topic, we will assume the reader is familiar with LDPC codes).  Suppose
 that we receive a codeword from a 4-bit LDPC error-correcting code that has been corrupted by noise.  
The sender wishes to communicate a four-bit codeword (a1,a2,a3,a4)   (satisfying some parity check equations), 
but the receiver only observes the corrupted values (b1,b2,b3,b4) . (The domain of the bi  is determined by the 
communication channel.  For instance, if we have a discrete binary symmetric channel, then the bi  will be bits; 
if we have a continuous additive white Gaussian noise channel and some modulation scheme, the bi  will be real-valued.) 
Let H  be the parity check matrix of the LDPC code used, i.e. the codeword (a1,a2,a3,a4)  verifies the equation

[latex]
$ Ha=0(mod2) $

For instance, suppose that H is the following parity check matrix:

[latex]
\[
H = \left( \begin{array}{cccc}
1 & 1 & 0 & 1 \\
1 & 1 & 1 & 0 \\
0 & 1 & 1 & 1 \end{array} \right) 
\]

Suppose that the error is independent, i.e., if we condition on a~i~, b~i~ is conditionally independent. 
Then, the following factor graph represents the decoding task at hand.

image:images/DecoderExample.png["stuff",height=100]

The construction above applies to any linear binary ECC.  However, if every row and column of H is sparse (as would be the case with an LDPC code), then every factor is small, and every node in the factor graph will be of small degree.

Given a factor graph, the objective is often to compute the marginal distribution of the random variables a~i~ of the graph (this also allows us to find the most likely value taken by each variable, by maximization of the marginal probability). {swname} provides an implementation of belief propagation (BP) (in its sum-product version), in order to approximately compute the marginal distribution of each random variable. 

BP is an iterative message-passing algorithm where messages pass along the edges of the factor graph.  A “message” can be viewed as an un-normalized probability distribution.  The algorithm comes in a number of variants depending on the message update rule and the order of the message updates.  

Sum-Product generalizes a number of algorithms, including the “forward-backward” algorithm of HMMs, and the BCJR algorithm of coding theory. It always gives the exact answer (upon convergence), when the underlying factor graph is a tree. Although it is not an exact algorithm for general graphs, BP has been found to give excellent results for a wide variety of factor graphs, and runs particularly fast on sparse factor graphs (i.e. factor graphs of low node and factor degree).

{swname} User Tutorial
----------------------
This tutorial describes how to code using the MATLAB {swname} client. We provide four tutorials. The first example is a simple hidden Markov model. The second models a 4-bit XOR. The third tutorial explains how to use nested graphs. The final is an LDPC code.
See /demo/12_Tutorial for the code. 

Creating and Solving a Simple Factor Graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The HMM Model
^^^^^^^^^^^^^
We consider a very simple HMM, the Rainy/Sunny HMM illustrated in the Wikipedia article about HMMs. Two friends who live far apart, Alice and Bob, have a daily phone conversation during which Bob mentions what he has been doing during the day. Alice knows that Bob’s activity on a given day depends solely on the weather on that day, and knows some general trends about the evolution of weather in Bob’s area.

Alice believes she can model the weather in Bob’s area as a Markov chain with two states ‘Sunny’ and ‘Rainy’. She remembers hearing that on the first day of last week it was quite likely (70% chance) that it was sunny in Bob’s town. She also knows that a sunny day follows another sunny day with 80% chance, while a sunny day succeeds a rainy day with 50% chance.

She knows Bob pretty well, and knows that Bob only ever does one of three things: stay inside to read a book, go for a walk, or cook. She knows that if it is sunny, Bob will go for a walk with 70% probability, cook with 20% probability, and stay inside with 10% probability. Conversely, if it is rainy, Bob will go for a walk with 20% probability, cook with 40% probability, and stay inside with 40% probability. 

Bob told Alice that he went for a walk on Monday, Tuesday, and Thursday, cooked on Wednesday and Friday, and read a book on Saturday and Sunday.

Alice wants to know what the most likely weather is for every day of last week. The above naturally defines an HMM which can easily be modeled within {swname}

Creating the Factor Graph
^^^^^^^^^^^^^^^^^^^^^^^^^
The first command in a {swname} program, is to create a factor graph. This is easily done with the FactorGraph() command. See /demo/12_Tutorial/{swname}Tutorial_HMM.m


----
HMM = FactorGraph();
----

Declaring Variables
^^^^^^^^^^^^^^^^^^^
Once a Factor Graph has been defined, we can define the variables of the factor graph.  In our case, there will be seven variables, MondayWeather… to SundayWeather. The command to create a variable is Discrete(domain,dimensions). In our case, the domain will consist of the two distinct values ‘Sunny’ and ‘Rainy’. For now, we will not specify dimensions (this will be covered in 4 Bit XOR tutorial). The domain should either be a cell, or a matrix of numbers.


----
Domain={'sunny','rainy'};
MondayWeather=Discrete(Domain);
TuesdayWeather=Discrete(Domain);
WednesdayWeather=Discrete(Domain);
ThursdayWeather=Discrete(Domain);
FridayWeather=Discrete(Domain);
SaturdayWeather=Discrete(Domain);
SundayWeather=Discrete(Domain);
----

IMPORTANT: In the above, had we used the declaration Domain=[‘sunny','rainy'] instead (square brackets instead of curly brackets), the domain would have consisted of 10 letters instead of 2 strings (i.e. the variables would have been 10-ary instead of).

Adding Factors
^^^^^^^^^^^^^^
We now add the different factors of the factor graph. We will first add the factors corresponding to the Markov Chain structure. This is done with the command addFactor, which is a method of the factor graph previously defined. The command has syntax addFactor(funchandle,arguments), where funchandle is the handle of a regular MATLAB function (which can be specified by the user), and the arguments are the variables involved in the factor being defined (in the same order as the inputs of the MATLAB function). The number of inputs of the function referred to by the function handle has to be equal to the number of arguments of addFactor.

In our case, we define a simple MC_transition_Tutorial(state1,state2) as follows (See /demos/12_Tutorial/MC_transition_Tutorial.m):


----
function [probability]=MC_transition_Tutorial(state1,state2)
 
switch state1
    case 'sunny'
        if state2=='sunny'
            probability=0.8;
        else
            probability=0.2;
            
        end
        
    case 'rainy'
        probability =0.5;
end 
----

We can now add the factor to the factor graphs by using the addFactor method:


----
HMM.addFactor(@MC_transition_Tutorial,MondayWeather,TuesdayWeather);
HMM.addFactor(@MC_transition_Tutorial,TuesdayWeather,WednesdayWeather);
HMM.addFactor(@MC_transition_Tutorial,WednesdayWeather,ThursdayWeather);
HMM.addFactor(@MC_transition_Tutorial,ThursdayWeather,FridayWeather);
HMM.addFactor(@MC_transition_Tutorial,FridayWeather,SaturdayWeather);
HMM.addFactor(@MC_transition_Tutorial,SaturdayWeather,SundayWeather);
----

We now need to add factors corresponding to the observations of each day. As it happens, when using an addFactor command, the arguments need not be all random variables – some can be declared as constants. We see now how to use this fact to easily add the observations to each day. We first declare an observation function (see /demo/12_Tutorial/observation_function_Tutorial.m):


----
function [probability]=observation_function_Tutorial(state,observation)
 
switch state    
    case 'sunny'
        
        switch observation
            
            case 'walk'
                probability=0.7;
            case 'book'
                probability=0.1;
            case 'cook'
                probability=0.2;
        end
        
    case 'rainy'
        
        switch observation
           
            case 'walk'
                probability=0.2;
            case 'book'
                probability=0.4;
            case 'cook'
                probability=0.4;
        end
end
----

Adding the observations is then very easy:


----
HMM.addFactor(@observation_function_Tutorial,MondayWeather,'walk');
HMM.addFactor(@observation_function_Tutorial,TuesdayWeather,'walk');
HMM.addFactor(@observation_function_Tutorial,WednesdayWeather,'cook');
HMM.addFactor(@observation_function_Tutorial,ThursdayWeather,'walk');
HMM.addFactor(@observation_function_Tutorial,FridayWeather,'cook');
HMM.addFactor(@observation_function_Tutorial,SaturdayWeather,'book');
HMM.addFactor(@observation_function_Tutorial,SundayWeather,'book');
----

As we can see, though the functions itself depends on two variables, each factor only depends on one random variable (the other argument being set as a constant during the addFactor call). This in effect creates a factor connected only to one variable of the factor graph.

There is a cost incurred everytime addFator is called.  For large Factor Graphs with many factors of the same type, it can be advantageous to use a vectorized version of addFactor.  The following code will create a transition factor between each pair of consecutive variables and will execute much more quickly than a for loop with addFactor.

----
N = 1000;
Weather = Discrete(Domain,N,1);
HMM.addFactorVectorized(@MC_transition_Tutorial,Weather(1:(end-1)),Weather(2:end));
----

This works with continuous variables and Nested Graphs as well.  In addition, it's possible to specify which dimensions to vectorize over:

----
N = 20;
b = Bit(3,N);
fg = FactorGraph();
fg.addFactorVectorized(@xorDelta,{b,2});
----

The previous code will create N xor factors across each of the N sets of 3 variables.


Specifying Inputs
^^^^^^^^^^^^^^^^^

The last step consists in adding the prior for the MondayWeather variable. We could, as above, use a factor with a single variable. Let us introduce a new command to easily add a single variable factor – the input method (on variables).

For a vector of probabilities (i.e. nonnegative numbers which sums up to one), the method Variable.Input adds a single factor which depends on this variable only, with values equal to those given by the vector.

In our case, we do:


----
MondayWeather.Input=[0.7 0.3];
----

The Input command can be used in several different ways. Some notes of interest regarding the Input command:

* The Input command can typically be used for prior probabilities of the root variables in a Bayes Net, or for the initial node of a Markov Chain or HMM.
* The Input command can also be used for any factors with only one variable, for instance, for observation factors (see the introduction to factor graphs on how to remove observations and turn them into single node factors).
* The observation_function_Tutorial in the above example was not entirely (see below) required – as we could have used the input command instead.
* IMPORTANT: Unlike the addFactor command, the Input command can be used only once for each variable. That is, once you have specified an input for a variable, re-specifying this input will destroy the previous factor and create a new one. In the example above, using only the Input command, it would not have been possible to separately incorporate both the prior on Monday’s weather and the factor corresponding to Monday’s observation. However, this feature is very useful when Input is used to specify external information, and when the user wants to see the effect of external information. Say for instance that Bob mentions to Alice that it rained on Wednesday. Alice can simply use the command WednesdayWeather.Input=[0 1]. If Bob corrects himself and says he misremembered, and that it actually was sunny that day, Alice can correct the information using again the command WednesdayWeather.Input=[1 0].

Solving the Factor Graph
^^^^^^^^^^^^^^^^^^^^^^^^
Finally, we explain how to solve the factor graph by using the solve, iterate, and NumIterations factor graph methods.

The typical way of solving a factor graph will be by choosing the number of iterations and then running the solver for the desired number of iterations. In our case, this is simply done by typing the following commands:


----
HMM.NumIterations=20;
HMM.solve;
----

[IMPORTANT]
===============================
By default, the solver will use either a Flooding Schedule or a Tree Schedule depending on whether the factor-graph contains cycles.  A loopy graph (one containing at least one cycle) will use a Flooding Schedule by default.  This schedule can be described as:

* Compute all variable nodes
* Compute all factor nodes
* Repeat for a specified number of iterations.

If the factor-graph is a tree (one that contains no cycles), the solver will automatically detect this and use a Tree Schedule by default.  In this schedule, each node is updated in an order that will result in the correct beliefs being computed after just one iteration.  In this case, NumIterations should be 1, which is its default value.
===============================


Accessing Results
^^^^^^^^^^^^^^^^^
Once the solver has finished running, we can access the marginal distribution of each variable by using the Belief command


----
TuesdayWeather.Belief
----

This returns a vector of probability of the same length as the domain total size (i.e. the product of its dimensions), with the probability of each domain variable.
Another way to solve the factor graph is to use the Solver.iterate(n) command, which runs the factor graph for n iterations (without arguments, it runs for 1 iteration).


----
HMM.Solver.iterate();
HMM.Solver.iterate(5);
----

IMPORTANT: The iterate command is useful to access intermediate results (i.e, see how beliefs change through the iterations).

IMPORTANT: One distinction between the solve and iterate commands is that all messages and beliefs are reinitialized when starting the solve command. Running solve twice in a row is therefore identical to running it once, unlike iterate. Using solve with a 0 number of iterations is a way to reinitialize all messages.

A 4-bit XOR
~~~~~~~~~~~
The following tutorial will consist in defining a simple factor graph with 4 variables tied through a 4-bit XOR, with ‘priors’ (we abuse language here and call ‘prior’ the probability distribution of each random variable if they were not tied through the 4-bit XOR).

Through this tutorial, we will learn how to define arrays of random variables, see how to use MATLAB indexing within {swname}, see an example of a hard constraint in a factor graph, and see how to use the Bit type of random variable.

We consider a set of four random variables (B1,B2,B3,B4) taking values 0 or 1. The joint probability distribution is given by:


[latex]
$ Pr(B_1,B_2,B_3,B_4) = \delta_{B_1+B_2+B_3+B_4=0(mod2))} 
P(B_1)P(B_2)P(B_3)P(B_4)  $

where the delta function   is equal to 1 if the underlying constraint is 
satisfied, and 0 otherwise (this ensures that illegal assignment have 
probability zero). The P(B~i~) are single variable factors which help model 
which values of B~i~  are more likely to be taken (we call them ‘priors’, 
though, once again, this is an abuse of language. Typically, the factor
 will represent an observation of  O~i~  of variable  B~i~, and the factor 
P(B~i~)  is 
set equal to the normalized function  P(O~i~|B~i~) 
footnote:[Normalizing P(O~i~|B~i~) happens to be equal to P(B~i~|O~i~) in a
factor graph with only the two variables O~i~ and B~i~ with a prior on both values of 
B~i~ being equally likely. ]
 ).

For our example, we will choose  P(B~1~=1)=P(B~2~=1)=P(B~3~=1)=.8 and  
P(B~4~=1) = 0.5.

We will build our factor graph in two different ways. The first directly uses a 4-bit XOR, and uses mostly tools seen in the previous tutorial, while the second introduces the Bit kind of random variable, and how to use an intermediate variable to reduce the degree of a factor graph with parity checks (i.e. XOR function).

The first way of building the factor graph uses an inefficient N-bit XOR function defined as follows (from /demo/12_Tutorial/BadNBitXorDelta_Tutorial.m):


----
function [valid]=BadNBitXorDelta_Tutorial(variables) valid=mod(sum(variables),2)==0;end
----

Using everything we have learned in the previous tutorial, the sequence of instructions we use is simply (from /demo/12_Tutorial/{swname}Tutorial_BadNBitXor.m):



----
FourBitXor=FactorGraph();Domain=[0;1];B1=Discrete(Domain);B2=Discrete(Domain);B3=Discrete(Domain);B4=Discrete(Domain);FourBitXor.addFactor(@BadNBitXorDelta_Tutorial,[B1,B2,B3,B4]);B1.Input=[0.2 0.8];B2.Input=[0.2 0.8];B3.Input=[0.2 0.8];B4.Input=[0.5 0.5];FourBitXor.NumIterations=30;FourBitXor.solve;disp(B1.Value);
----

IMPORTANT: Note that the BadNBitXorDelta_Tutorial is a function which takes only ONE argument, but this argument is an array. This is reflected in the declaration FourBitXor.addFactor(@BadNBitXorDelta_Tutorial,[B1,B2,B3,B4]),where we created an array of random variables using square brackets.

IMPORTANT: We also introduce the Discrete method ‘Value’, which returns the most likely assignment of that random variable.

The first remark above is rather important, as it highlights of the concept of arrays of random variables in {swname}.  {swname} handles arrays of random variables in a very natural manner, and most array indexing operations of MATLAB are supported in {swname} in a similar fashion.To create a multidimensional array of random variables in {swname}, we use the Variable command where every argument after the first is a dimension of an array: VarArray=Variable(Domain,dimension1,dimension2,.., dimensionk) creates an array of variables with domain ‘Domain’, and with dimensions [dimension1][dimension2]..[ dimensionk]. 

IMPORTANT: If only one dimension is specified, {swname} creates a square array.


----
VarArray1=Discrete(Domain,3,1)VarArray2=Discrete(Domain,3)VarArray3=Discrete(Domain,3,3)
----



In the example above, VarArray1 is a vector of 3 random variables with domain Domain, while VarArray2 and VarArray2 are both a 3-by-3 matrix of random variables with domain Domain.

Another way to create an array is, as above, to group the variables using square brackets:


----
RowArray=[ B1 B2 B3 B4];
ColumnArray=RowArray’;
----

IMPORTANT: The above command is a simple ‘grouping’ (reference) of variables  ; it does not duplicate them.

Concatenation and subindexing of random arrays work in exactly the same fashion as MATLAB.


----
SubArray1=VarArray2(2,1:2);
SubArray2=VarArray2(1,2:3);
SubArray3=[SubArray1;SubArray2];
----

repmat works as well.  The following code snippet will set C to a 10x10 Bit matrix.  Rather than creating new
variables, it simply replicates the existing variables.  

----
b = Bit(10,1);
c = repmat(b,1,10);
----



Using the Variable methods Belief, Value or Domain on a random array returns the array of Beliefs (resp. ML values, domains, etc..) for these variables.


----
SubArray2.Value
----

returns a (1,2) array containing the most likely values of VarArray2(1,2) and VarArray2(1,3).

IMPORTANT: Since Beliefs or Inputs are arrays themselves, calling them on an array returns an array one dimension larger.

Often, we will find it useful to have random Bits. For that purpose, one can directly create random Bits with the command Bit. A Bit is simply a Discrete with Domain [1;0] (note the ordering). Also, in order to simplify Input declarations, for a Bit variable named BitVar, BitVar.Input takes a single number, the probability of 1. Similarly, BitVar.Belief returns the marginal probability of BitVar being equal to 1.

The second version of the 4-bit XOR will uses Bit variables to represent our random variables. Furthermore, it will decompose the 4 bits XOR into two 3-bits XOR. It is indeed easy to prove that


[latex]
$ B_1 + B_2 + B_3 + B_4 = 0(mod 2) $

is equivalent to



[latex]
\begin{eqnarray*}
B_1+B_2+C &=& 0(mod 2) \\
B_3+B_4+C &=& 0(mod 2)
\end{eqnarray*}

for an internal bit C. While the reduction from one 4-bit to two 3-bit XORs might not seem tremendous, it is easy to see that more generally, any N-bit XOR can be reduced to a tree of 3-bit XORs, with depth log(N). Because the complexity of running Belief Propagation is exponential in the degree of factors, using this technique leads to dramatic speed improvements.

Using all the techniques mentioned above, we derive a new factor graph for the 4-bit XOR, equivalent to the one previously defined (from /demo/12_Tutorial/xorDeltaTutorial.m):


----
function valid = XorDeltaTutorial(x,y,z)       
    valid = bitXor(bitXor(x,y),z);
end
----

From demo/12_Tutorial/{swname}Tutorial_4BitXor.m:


----
XorGraph = FactorGraph();
b = Bit(4,1);
c = Bit();
XorGraph.addFactor(@XorDeltaTutorial,b(1),b(2),c);
XorGraph.addFactor(@XorDeltaTutorial,b(3),b(4),c);
b.Input = [ .8 .8 .8 .5];
XorGraph.NumIterations = 2;
XorGraph.solve();
disp(b.Belief);
disp(b.Value);
----

The following figure represents the Factor Graph that is created and solved in this example.

image:images/FactorGraphTemplate.png["Factor Graph Template",height=75]

Nested Graphs
~~~~~~~~~~~~~
Suppose we wish to use two 4-bit XORs from the previous example to create a 6-bit code.  The following diagram shows our desired Factor Graph.

image:images/NestedGraph.png["Nested Graph",height=100]

{swname} provides a way to replicate multiple copies of a Factor Graph and nest these instances in a containing Factor Graph. A nested Factor Graph can be seen as a special factor function between a set of variables (‘connector variables’), which, when ‘zoomed in,’ is in fact another factor graph, with factors involving both the connector variables, and other ‘internal variables.’ In the second version of the XOR tutorial, we created a 4-bit XOR connected to 4 variables, by also creating an extra Bit C. What if we wanted to use that construction as a 4-bit XOR for potentially many different sets of 4 bits, overlapping or not, by replicating the factor graph as needed? Nested factor graphs provide an elegant solution to this problem.

A nestable factor graph is created by specifying first a set   of ‘connector’ random variables, and invoking the command FactorGraph(S).

IMPORTANT: The factor graph defined this way is still a proper factor graph, and in principle, we can run BP on it. However, in practice, it is used as a ‘helper’ factor graph (and   are ‘helper’ random variables), which will mostly be replicated in the actual factor graph of interest.

The following code creates a nestable factor graph, with connector variables (B~1~,B~2~,B~3~,B~4~) 
(from /demo/12_Tutorial/{swname}TutorialNested.m):


----
% Define 4 bit Xor from two 3 bit Xors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
b = Bit(4,1);
XorGraph = FactorGraph(b);
c = Bit();
XorGraph.addFactor(@XorDeltaTutorial,b(1),b(2),c);
XorGraph.addFactor(@XorDeltaTutorial,b(3),b(4),c);
----

IMPORTANT: In principle, variables attached to a Factor Graph can be defined before or after defining the factor graph (but obviously always before the factors they are connected to). However, connector variables naturally need to be defined before the nestable factor graph.

image:images/BoundaryVariables.png['Boundary Variables',height=100]

Consider a nestable factor graph NestableFactorGraph(connectvar1, connectvar2,..,vark) with k connector variables. Consider also an actual factor graph of interest, FactorGraph, containing (among others) k variables of interest (var1,..,vark). By using the addGraph command, we can replicate the NestableFactorGraph and use it to connect the variables (var1,..,vark) in the same way the connector variables are connected in the nestable factor graph. The command is: FactorGraph.addGraph(NestableFactorGraph,var1,..,vark).

In essence, the nestable factor graph represents a factor between the dummy connector variables, and the addGraph command is adding the factor to the desired actual variables.

IMPORTANT: Nested factor graphs support arbitrary levels of nesting – that is, a nested factor graph can be composed of nested factor graphs.

Armed with this tool, we can very simply use our custom 4-bit XOR to implement the factor graph described at the beginning of the section:


----
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create graph for 6 bit code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    


d = Bit(6,1);
MyGraph = FactorGraph(d);
MyGraph.addGraph(XorGraph,d([1:3 5]));
MyGraph.addGraph(XorGraph,d([1 2 4 6]));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set input and Solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

d.Input = [.75 .6 .9 .1 .2 .9];
MyGraph.NumIterations = 20;
MyGraph.solve();
disp(d.Value');
----



IMPORTANT: Note the use of standard MATLAB array indexing in the d([1:3 5]) command above. Also, note that technically, our nestable factor graph declared above only had one argument (not four), an array of four random variables (as opposed to four separately declared random variables). As a result, the addGraph call requires a single argument – an array of four random 

LDPC Example
~~~~~~~~~~~~
For our last example, we will show how to use a library function to very quickly code up a complex factor graph.

We present the code that defines a Factor Graph to decode an LDPC code (in the file \demo\11_SingleCodewordLDPC\createLDPC.m):

----
function [ldpc,x] = createLdpc()
    A = load('matrixout.txt');
    blockLength = size(A,2);
    numCheckEquations = size(A,1);
    ldpc = FactorGraph();   
        x = Bit(blockLength,1);     
        for i = 1:numCheckEquations
            varIndices = find(A(i,:));
            gd = getNBitXorDef(length(varIndices));
            ldpc.addGraph(gd,x(varIndices));
        end       
     ldpc.NumIterations = 100;
end
----

At this point, all the code above should be clear, except for the getNBitXorDef call. getNBitXorDef(N) returns a nestable factor graph with an array of N bits as connected variables, representing an N-bit XOR factor between those N bits. It implements the most efficient (in some sense) implementation of an N-bit XOR using a tree of 3-bits XORs.

The check matrix connectivity is loaded from a file into matrix A. The for loop iterates all check equations, creates a nestable n-bit XOR Graph and adds that graph to the LDPC.  The user can set Input on x and the returned variables, solve the ldpc object, and retrieve the results with Value or Beliefs.

Memory Management
~~~~~~~~~~~~~~~~~

Each MATLAB object corresponds to underlying java objects. Whenever a MATLAB Variable or FactorGraph is freed the corresponding java objects are also cleared from memory.

A caveat is that the amount of heap memory reserved for Java (when called from MATLAB) is limited, and typically low. To change this value, edit the file java.opts in the MATLAB startup directory, and add the following two lines

----
-Xmx1024m
-Xms512m
----

where the value after Xmx is the maximum amount of heap memory allocated to Java, and Xms is the minimum one.

Prepackaged Factor Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If {swname} is installed correctly, the users will have {swname}/lib on their path and can use the Lyric {swname} prepackaged factor functions. 

Some of these are standard MATLAB functions, and can be used with the addFactor method to create factors. They are:

* andDelta(inputs,output), where inputs is the array of input Bit variables, and output is a single ‘output’ Bit variable (input and output variables are connected to the factor). Constrains the output variables as the logical AND of the input variables (i.e., the output is 1 if the constraint is satisfied, and zero otherwise)
* orDelta(inputs,output), where inputs is the array of input Bit variables, and output is a single ‘output’ Bit variable (input and output variables are connected to the factor). Constrains the output variables as the logical OR of the input variables (i.e., the output is 1 if the constraint is satisfied, and zero otherwise)
* xorDelta(inputs), where inputs is the array of input Bit variables. Constrains the parity of the sum of the input variables to be even (logical XOR). This implementation of the XOR function is inefficient (large degree).
* carryless_add( x,y,z ). Constrains x+y to be equal to z (over the reals), where x, y and z are m-ary variables.

Some other functions return nestable graphs, and are used with the addGraph method to create factors. They are:

* getNBitXorDef(n), where n is a positive integer. Returns a nestable graph and an array of n-Bit connector variables. Efficient tree implementation of the XORDelta function.
* getVXOR(n), where n is a positive integer. Returns a nestable graph and an array of n-Bits connector variables. Constrains exactly one bit to be 1, and all others to be 0.

Rolled Up Factor Graphs
~~~~~~~~~~~~~~~~~~~~~~~

Markov Model
^^^^^^^^^^^^

In our first rolled up graph we build a simple Markov model describing an infinite stream of variables.   

----
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Markov Model
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Build nested graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%Here we build a graph that connects two variables by an xor %equation An xor equation with only two variables is the %equivalent of an equals constraint.
 
in = Bit();
out = Bit();
ng = FactorGraph(in,out);
ng.addFactor(@xorDelta,in,out);
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%create rolled up graph.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%Now we build a FactorGraph that creates an infinite chain of %variables.
bs = BitStream();
fg = FactorGraph();
 
%Passing variable streams as arguments to addFactor will result %in a rolled up graph.  Passing in a slice of a variable stream %specifies a relative offset for where the nested graph should %be connected to the variable stream.
fs = fg.addFactor(ng,bs,bs.getSlice(2));
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%create data source
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
data = repmat([.4 .6],10,1);
ds = DoubleArrayDataSource(data);
bs.DataSource = ds;
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%solve and get beliefs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%We have to initialize now since we will avoid initializing on %every call to solve.
fg.initialize();
 
while 1
    
    %The "false" argument specifies that we should avoid 
    %re-initializing
    %the messages on the graph.  This is necessary since we 
    %don't want to lose information from the past.
    fg.solve(false);
    
    %There are multiple ways to retrieve variables from variable 
    %streams.  The "FirstVar" property will retrieve the oldest 
    %variable in the buffer.
    disp(bs.FirstVar.Belief);
 
    %hasNext returns true if there is data for every 
    %VariableStream connected to a data source in this 
    %FactorGraph.
    if ~fg.hasNext()
        break;
    end
    
    %Advance moves the buffer forward, retrieves data for new 
    %variables,and keeps track of messages coming from the past.
    fg.advance();
    
end
----
Let’s talk about some of the aspects of rolled up graphs illustrated in this example in more detail:

.Variable Streams and Slices

Variable Streams represent infinite streams of variables.  When instantiating a VariableStream, users have to specify a domain.  The following are examples of instantiating Discrete VariableStreams:

* DiscreteStream(DiscreteDomain({0,1,2}));
* DiscreteStream({0,1,2}); - equivalent to the previous example
* DiscreteStream({0,1}); - A stream of bits
* BitStream(); - Shorthand for the previous example.

When adding a repeated FactorGraph, users need to be able to specify how a nested graph connects to the variable streams.  Slices can be used to indicate where in the stream a nested graph should connect.  Slices are essentially references to a Variable Stream with a specified offset and increment.  Slices have two main methods:

* hasNext() – Returns true if the next variable referenced by the slice can be retrieved.
* getNext() – Returns the next variable in the  slice if it can be referenced.  Otherwise throws an error.

Users typically shouldn’t use these methods.  Slices should primarily be used as arguments to addFactor.

First we need to instantiate a variable stream:

----
S = BitStream();
----

Now we can get slices in various ways:

* S.getSlice(start,increment,end); 
** Start – Specifies this slices starting point as an index into the variable stream.
** Increment – When users call getNext() on a slice, this increment parameter describes how to increment the index into the variable stream.
** End – Indicates at what point hasNext() should return false regardless of whether there is data or not.
* S.getSlice(start,end) – equivalent to S.getSlice(start,1,end);
* S.getSlice(start) – equivalent to S.getSlice(start,1,Inf);

.Buffer Size
Users can specify a bufferSize for each FactorGraph stream.  A FactorGraphStream is instantiated every time addFactor is called with a nestedGraph and VariableStreams or Slices.  The default bufferSize is 1.  Solving a graph with bufferSize one will result in a forward only algorithm.  The bufferSize indicates how many nested graphs to instantiate for one step.  In our Markov Model example, when buffer size is set to 1 and we plot the graph before solving we see this:

image:images/BufferSize1.png["buffer size 1",height=100]

We see one factor and two instantiated variables.  If we set bufferSize to 5 and plot we get:

image:images/BufferSize5.png["buffer size 1",height=100]

We see five factors and 6 variables.  After the first time we call “advance”, BlastFromThePast factors will be added to the oldest variable.  These factors contain messages from the past. 
There are two ways to set the BufferSize for a FactorGraph stream:

* Fg.addFactor(ng,bufferSize,sream,slice,etc…); - Specified as second argument to addFactor.
* Fgs = fg.addFactor(ng,stream,slice,etc…);
fgs.BufferSize = bufferSize; - Set on the FactorGraphStream directly.

.DataSources
Users can create data sources and attach them to VariableStreams.  As variables are created, data is retrieved from the DataSources and applied as inputs to the variables.  If a VariableStream is never connected to a DataSource, hasNext() will always return true for that VariableStream.  When a VariableStream is connected to a data source, hasNext() only returns true when there’s more data in the DataSource.


DataSources must implement the hasNext and getNext methods.  The only DataSource type currently implemented is DoubleArrayDataSource.  Methods include:

* DoubleArrayDataSource(); - Constructor that creates an empty data source
* DoubleArrayDataSource(data); - Constructor that expects a matrix as input.  The first dimension is the list of data, the second dimension is a double array that gets applied to a variable’s input.
* Add(data); - Users can add  more data to the end of the data source.

.Solving
Eventually we may implement data sinks to that rolled up graphs can stream without function calls.  Currently, users must write code to advance the streams, solve, retrieve data, and poll for ending conditions.  You can see in the code example how the following methods are used:

* Fg.hasNext() – Returns true only if all of the Variable Streams have more data (or have no data source set)
* Fg.advance() – Deletes the first nested graph in the buffer for each FactorGraphStream, adds a new Nested Graph at the end, deletes obsolete variables, and adds data to newly created variables.
* Fg.initialize() – This method can be used even without rolled up graphs.  It initializes all the messages in the graph.  We need to use this in rolled up graphs because we tell solve not to initialize so as not to lose old information.
*Fg.solve(false) – Solve is usually called without an argument (default argument is true).  Setting the argument to false avoids initialization.
* Fg.reset() – Once users have created a graph, they may want to use the same graph to run multiple times.  Setting reset on the FactorGraph will remove BlastFromThePast factors end set stream and slice indices back to their starting points.

.Accessing Variables
In the absence of data sinks, users need a way to retrieve variables to get beliefs.   The following methods allow the user to do that:

----
Vs = BitStream();
----

* Vs.FirstVar – Returns the first variable in the buffer.
* Vs.LastVar – Returns the last variable in the buffer.
* Vs.FirstVarIndex – Returns the index of the first variable in the buffer (used with get method)
* Vs.LastVarIndex – Returns the index of the last variable in the buffer (used with get method)
* Vs.get(index) – Retrieves a variable of the specified index.  This is a 1-based value.

Markov Model with Parameter
^^^^^^^^^^^^^^^^^^^^^^^^^^^

When adding a repeated graph, it is possible to specify some variables as streams and others as individual variables.  We sometimes call these individual variables parameters.  Using this feature is straightforward:

----
ng = FactorGraph(a,b);
ng.addFactor(@xorDelta,a,b);
p = Bit();
s = BitStream();
fg = FactorGraph();
fgs = fg.addFactor(ng,p,s);
fgs.BufferSize = 5;
fg.plot();
----

This code results in the following graph:

image:images/RolledUpParameter.png["rolled up param",height=75]

Real Variables
^^^^^^^^^^^^^^
Rolled up graphs work with real variables as well.  Here we create another Markov Model.  We use the Gaussian solver that supports a custom factor called “constmult”.  We create a data source that only has information about the first variable.  The means beliefs are growing by 110% as we iterate through the stream because the factor provides a constraint that each variable is 110% of the previous variable.

----
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Set solver type so we can create reals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
setSolver('Gaussian');
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Build graph
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
a = Real();
b = Real();
 
ng = FactorGraph(a,b);
ng.addFactor(@constmult,b,a,1.1);
 
fg = FactorGraph();
s = RealStream();
 
fg.addFactor(ng,s,s.getSlice(2));
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%set data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
data = [1 .1; repmat([0 Inf],10,1)];
dataSource = DoubleArrayDataSource(data);
 
s.DataSource = dataSource;
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
fg.initialize();
 
while fg.hasNext()
    fg.solve(false);    
    disp(s.FirstVar.Belief(1));    
    fg.advance();
end
----

This produces the following output:

----
1
1.1000
1.2100
1.3310
1.4641
1.6105
1.7716
1.9487
2.1436
----

API Documentation
-----------------
The following section describes several classes (Discrete, Real, Bit, Factor, and FactorGraph) and the methods associated with each that comprise the MATLAB {swname} API.

Discrete Variables
~~~~~~~~~~~~~~~~~~
{swname} supports both Discrete and Real Variables.  Not all solvers support real variables.  Currently the MinSum and SumProduct solvers only support Discrete variables while the Gibbs and ParticleBP solvers do support Real Variables.

The Discrete class is either a single Discrete or a multidimensional array of Discrete variables.  All properties/methods can either be called for all elements in the collection or for individual elements of the collection.

Discretes can be created before the factor graph to which they will belong.

Constructor
^^^^^^^^^^^
----
domain = [0 1 2];
w = Discrete(domain)
x = Discrete(domain,4)
y = Discrete(domain,2,3)
z = Discrete(domain,2,3,4)
----

The Discrete constructor can be used to create an N-dimensional collection of {swname} Discretes.  It takes two arguments:

. Domain – All Variables are currently discrete variables with finite domains.
. A Variable List of Dimensions – The user can specify 0 to N dimensions for the Variable matrix.

Let’s examine each of these arguments in more detail in the following sections.

.Domain
A discrete random variable has a domain associated with it.  A domain is a set.  {swname} supports any object types as elements of the set.

The following are all valid domains:

----
a) a = Discrete({1,2,3})
b) b = Discrete({1+i, i, 2*i})
c) c = Discrete({[1 0; 0 1],[i 1, 2*i 1]})
d) d = Discrete({[1 0; 0 1],2,i+1})
----

(a) creates a variable whose domain consists of three values: 1, 2, and 3.  (b) creates a variable whose domain consists of three complex numbers.  (c) creates a variable whose domain consists of two elements, each of which is a 2x2 complex matrix.  (d) creates a variable whose domain consists of three elements: a matrix, real scalar, and complex scalar.

The domain elements have meaning when {swname} calls user-defined delta functions to generate its internal tables.  The user-defined delta functions will get called with the domain items of each variable.

In the previous example we used cell arrays to specify the elements of a domain.  To allow for more concise definitions of domains, users can also use vectors to create a domain:

----
a) a = Discrete(0:2)
b) b = Discrete([1 2 3; 4 5 6])
c) c = Discrete([0:2]’)
----

(a) creates a variable with a domain of {0,1,2}.  (b) creates a variable with a domain of {[1 4]’, [2 5]’, [3 6]’}.  (c) creates a variable with domain of {0,1,2}.

When a user specifies an n-dimensional matrix as a domain, the nth dimension determines the number of elements in the domain.  The rest of the dimensions apply to each domain item.  (c ), however, is a special case.  Column vectors are interpreted the same as row vectors.  If you want to create a Variable with a single item in its set, you will have to use the cell array syntax:

----
d = Discrete({0:2})
----

.Variable List of Dimensions
If the variable constructor is called without any dimensions, it will create a single Variable.  With one dimension n1, it will create a square array of dimensions n1 x n1. With k dimensions n1, n2, …, nk, it will create a multidimensional array of dimensions n1 x n2 x ... x nk.

Belief
^^^^^^^
For any single variable Var, the Belief method will return a vector whose length is the total number of elements of the domain of Var, with each element of the vector containing the probability of the corresponding element of the domain.

For an array of variables Var, the Belief method will return an array of vectors (i.e., an array one dimension larger) containing the beliefs of each variable.

----
disp(Var.Belief);
----

The Belief method is only accessible after having run the solver.

Name
^^^^^^
Users can both set and retrieve the name of Discrete Variables.  This is useful for debugging or plotting a graph.

Domain
^^^^^^^
For any variable, the Domain method returns the domain of that variable.

Input
^^^^^^^

For any variable, the Input method can be used to set and return the current ‘Input’ of that variable. An input is a single edge factor for a variable.

----
Var.Input=[0.3 0.7];
disp(Var.Input);
----

Bit
~~~~~

A Bit is a special kind of Discrete with domain [0 1]. Its constructor does not require a domain, only the list of dimensions of the Variable.

----
BitVar1=Bit();
BitVar2=Bit(3,1);
BitVar3=Bit(3,5,3);
----

For simplicity, the Input method only requires the probability of 1 (and returns that probability). Similarly, the Belief method returns the probability of 1.

----
BitVar1.Input=0.3;
BitVar2.Input=[0.3 0.2 0.5];
disp(BitVar3.Belief);
----

The last command returns a 3-by-5-by-3 array of numbers between 0 and 1.

Real Variables
~~~~~~~~~~~~~~~

MATLAB API
^^^^^^^^^^
.Constructors

Real([domainBound, input, dimensions])

All arguments are optional and can be used in any combination.

* domainBound is a two-element vector specifying a bound on the domain of the variable. The first element is the lower bound and the second element is the upper bound. -Inf and Inf are allowed values for the lower or upper bound, respectively.
* input is an instance of a Java class specifying the factor function. All such Java classes are derived from the base class FactorFunction, and must have the eval() method implemented so that the factor can be evaluated in Java.
* dimensions specify the array dimensions in the normal way.

Examples:

* Real() specifies a scalar real variable with an unbounded domain and with no input distribution.
* Real(4,1) specifies a 4x1 vector of real variables with unbounded domain and with no input distribution.
* Real([-1 1]) specifies a scalar real variable with domain from -1 to 1.
* Real([-Inf 0],4,10,2) specifies a 4x10x2 array of real variables, each with the domain from negative infinity to zero.
* Real(com.lyricsemi.dimple.client.FactorFunctions.ExampleFactor()) specifies a scalar real variable with a prior distribution specified by the Java FactorFunction called ExampleFactor.
* Real([0 1], com.lyricsemi.dimple.client.FactorFunctions.ExampleFactor(), 1,6) specifies a vector of real variables, each with a domain from 0 to 1, and with a prior distribution specified by the Java FactorFunction called ExampleFactor.

NOTE: the discrete variable constructor is now called Discrete. For backwards compatibility, the Variable constructor is still supported and can also be used to create a discrete variable.

.Methods
The following methods are supported:

* .Domain (get) returns the two-element vector specifying the bound on the domain specified during construction. If no domain had been set, the value is [-Inf Inf]. For an array of variables, .Domain returns the domain common to all of the variables in the array. Domain is not a settable parameter--it can only be set on construction.
* .Input (get) returns the Java object associated with the input. For an array of variables, .Input returns a cell-array of these Java objects with the same dimension as the variable. Some solvers that support real variables expect FactorFunctions as inputs.  Note that for each FactorFunction object, the eval method will return the value of the factor evaluated at the specified input value (example: v.Input.eval(1.75) for a scalar variable or vArr.Input{2,3}.eval(1.75) for an array of real-valued variables).
* .Input = (set) assigns the specified input to the variable. For some real variable solvers, the input must be a Java factor function object (a subclass of FactorFunction. For an array of variables, the assignment can be made for some or all variables. (Example: v.Input = com.lyricsemi.dimple.client.FactorFunctions.ExampleFactor())

.Factors for Real Variables

Factors can be added to a graph that are connected to real variables, discrete variables, or a combination of the two. Any factor that is connected to one or more real variables currently is constrained to use a factor function specified in Java. It cannot use a factor function specified in MATLAB and cannot use a factor table. Specifically, the factor function must be an instance of a Java class derived from the base class FactorFunction, and must have the eval() method implemented so that the factor can be evaluated in Java.

Example:

----
f = graph.addFactor(package.for.example.ExampleFactor(), realVar1, realVar2, discreteVar1, discreteVar2);
----

The FactorFunction includes an eval() method that is evaluated at run-time when the graph is being solved. The eval function must accept inputs that correspond to the number and type of variables associated with a factor. The function may allow a variable number of arguments, which allows a variable number of variables to be used in the addFactor call.

Because the eval() method in Java must evaluate values in the domain of all variables, all discrete variables used in conjunction with such a factor must have a domain that can be represented in Java (for example, a numeric domain).

Note that the FactorFunction constructor can have arguments so that a single FactorFunction derived class can be represent a parametrized family of distributions.

.Solvers
Currently, real variables are supported by several solvers including the Gibbs solver, Particle BP solver, and Gaussian solver.

Factor Graph
~~~~~~~~~~~~
The FactorGraph class represents a Factor Graph and contains a collection of all Factors associated with that Factor Graph and all Variables that are connected by Factors to that graph.

Constructor
^^^^^^^^^^^
For a regular factor graph (on which we actually wish to perform inference), the constructor is simply the command FactorGraph.

----
fg=FactorGraph();
----

For a nestable factor graph, we first need to declare the connector or helper variables, and use them as arguments of the factor graph declaration.

----
ConnectVar=Discrete(Domain,1,5);
NestableGraph=FactorGraph(ConnectVar);
----

The command above creates a nestable factor graph with connector variable ConnectVar (which is an array). Once the nestable factor graph is fully defined (i.e. all the factors have been added), knowing what the connector variables are is not useful anymore, as they only serve as dummy variables.

addFactor
^^^^^^^^^^

----
MyGraph.addFactor(@XorDeltaTutorial,x,y,z);	
----

The FactorGraph “addFactor” method takes two arguments

. A function handle. 
. A variable length list of Variables or matrices.

The following shows an example of mixing variables and constants as arguments to a {swname} function.

----
b = Bit(2,1);
MyGraph.addFactor(@XorDeltaTutorial,b(1),1, b(2));	
----

The constants can be any n-dimensional complex matrix.  

Creating a Factor involves creating an array known as a combination table, which contains all assignments of the variables resulting in a positive value of the function, along with a value vector, containing all the corresponding values of the functions. This table is then passed to the solver. Creating that table takes time (and typically space) proportional to the product of the size of the domains of all variables connected to that factor, thus requiring an exponential time in the degree of the factor.  The addFactor method attempts to save memory and time by re-using existing factors when addFactor is called with the same FactorFunction.  The caching mechanism uses the name of the function (using MATLAB’s func2str) as well as the domain values for all of the arguments to addFactor when deciding if a FactorTable can be re-used.  If this behavior is undesirable, the addFactorNoCache method can be used instead of addFactor.

The addFactor method can also be used in the following ways:

.Nested Graphs

addFactor(nestedGraph,variables) - This is the same signature as addGraph and simply detects nestedGraph is a FactorGraph and calls addGraph. addGraph is left as a function of FactorGraph so as not to break existing code, but you can now use addFactor instead.

.Specifying FactorTables

For all discrete factors, {swname} can build FactorTables under the hood. A Factor Table consists of a two dimensional array of integers and a single dimensional array of doubles. Each row of the two dimensional table represents a combination of variables for which the Factor Function returns a non-zero value. Each column represents a variable connected to the factor. The values of the table specify an index into the discrete domain of a variable. Each row of the two dimensional table corresponds to one entry of the array of doubles and that entry contains the return value of the Factor Function.

In some situations, a user might be able to build a FactorTable much more efficiently than {swname} can. {swname} tries all combinations of variable values exhaustively and discards combinations for which the Factor Function returns zeros. If the user can avoid this exhaustive search, they can build the FactorTable more quickly.

Once the user has created the table, they can add a Factor using this table in one of two ways. The first is to provide the indices and values directly to the addFactor call:

----
   %First let's just add the factor as indices and values
   fg = FactorGraph();
   b = Bit(2,1);
   ind = [0 0; 1 1];
   val = [1 1];
   fg.addFactor(ind,val,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
----
   
Notice that the indices and values chosen here will be equivalent to creating an equals factor between the two variables. In the following example we see that it's possible to first create a Table and then add a factor using that table. This has the advantage of using less overall memory if this same table will be used in multiple factors.

----
   %Now let's add the Factor using createTable to test we can share tables
   fg = FactorGraph();
   b = Bit(2,1);   
   t = FactorTable(ind,val,b.Domain,b.Domain);	
   fg.addFactor(t,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
----

Users can also create a FactorTable given a single n-dimensional matrix such that:

[latex]
$ val(x_1,...,x_n) = F(d_1(x_11),...,d_n(x_n)) $

Where val is the N dimensional matrix, F is the desired Factor Function, and di is a function mapping 1 based indices to domain elements of domain i.  This will result in an uncompressed table, so it doesn’t offer a speed improvement, but provides a convenient way to create Factors in some cases.

----
   fg = FactorGraph();
   b = Bit(2,1);
   val = [1 0; 0 1];
   t = FactorTable(val,b.Domain,b.Domain);
   fg.addFactor(t,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
----

or equivalently:

----
   fg = FactorGraph();
   b = Bit(2,1);
   val = [1 0; 0 1];
   fg.addFactor(val,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
----

In yet another way to specify FactorTables, users can create an empty Factor Table and use the “set” function to set values at specified domain combinations.

----
   fg = FactorGraph();
   b = Discrete({'on','off'},2,1);
   t = FactorTable(b.Domain,b.Domain);
   t.set('on','on',1);
   t.set('off','off',1);
   fg.addFactor(t,b);
   b(1).Input = [.8 .2];
   fg.solve();
   assertEqual(b(2).Belief(1),.8);
----

Users can retrieve values using the FactorTable “get” function.

----
>> t.get('on','on')

ans =

     1
----

.Specifying Java Factor Functions 

There are some cases in which it is desirable to add a factor function that is defined in Java rather than MATLAB. Specific cases where this is desirable are:

* The user wants to use a sample-based solver. {swname}'s sample based solvers must use java Factor Functions in order to be able to call the Factor Function at runtime. This is partly because MATLAB does not officially support callbacks from Java to MATLAB and also because calls from Java to Java will be faster than those that cross a language boundary.
* The user wants their code to run faster. MATLAB function calls are very slow as compared to java function calls.
The following sections provides the steps users must follow to add a Java Factor Function to their FactorGraph.


.Create a class that inherits from JavaFactorFunction

Users must extend the FactorFunction class. They have to provide two methods:

* A constructor that call's the parent constructor.
* An eval function that returns a weight for each possible set of inputs.

----
import com.lyricsemi.dimple.FactorFunctions.core.FactorFunction;

/*
 * This factor enforces equality between all variables and weights
 * elements of the domain proportional to their value
 */
public class BigEquals extends FactorFunction
{	
    public BigEquals() 
    {
	super("BigEquals");
    }
  
    @Override
    public double eval(Object... input) throws Exception 
    {
	if (input.length == 0)
	    return 0;
	else
	{
	    double first = (Double) input[0];
	    
	    for (int i = 1; i < input.length; i++)
	    {
	        if ((Double)input[i] != first)
		    return 0;
	    }
	    return first;   
	}
    }
}
----

.Compiling

The new class must be compiled to class files. Users can optionally create a jar file. If using Eclipse, users can simply create a new project, create the new class, and the .class files will be created automatically.

.Adding Binary to MATLAB Path

In MATLAB, the user must use the javaaddpath call to add the java files to the javaclasspath.

----
javaaddpath('<path to my project>/MyFactorFunctions/bin');
----

or

----
javaaddpath('<path to the jar>/myjar.jar');
----

.Using the Factor Function

Users can now instantiate the FactorFunction and call addFactor with the instance.

----
be = BigEquals();
fg = FactorGraph(); 
v = Variable({0,1,2},2,1);
fg.addFactor(be,v(1),v(2));
fg.solve();
v(1).Belief
----

Note that the BigEquals class was added to the default package, so we can just call:

----
be = BigEquals();
----

The previous code results in the following answer from MATLAB:

----
ans =

   0.0000    0.3333    0.6667
----

.Re-using the Factor Function
We can re-use the BigEquals() FactorFunction multiple times within a single graph or across graphs. This will result in caching of FactorTables when the arguments to the addFactor function have identiical domains.

----
be = BigEquals();
fg = FactorGraph(); 
v = Variable({0,1,2},2,1);
fg.addFactor(be,v(1),v(2));
fg.solve();
v(1).Belief

fg2 = FactorGraph();
v2 = Variable({0,1,2},2,1);
fg2.addFactor(be,v2(1),v2(2));
fg2.solve();
v2(1).Belief
----

.AddFactorNoCache

There are several cases where {swname}’s factor caching mechanism is undesirable.  As an example, if the user is calling addFactor with the same factor many times, but they know the arguments are unique, they can save time by skipping the code that searches for a match in the cache. 

----
fg = FactorGraph(); 
func = @(x,y) 1;
b = Bit(2,1);
for i=1:1000
fg.addFactorNoCache(func,b,rand());
end
----

This is a somewhat contrived example but, in this case, replacing addFactorNoCache with addFactor will significantly slow down the code.

addFactorVectorized
^^^^^^^^^^^^^^^^^^^
To get reasonable speed out of MATLAB, one needs to vectorize their code.  If a user wishes to build a FactorGraph with large numbers of factors, 
they will want to avoid making many calls to addFactor.  The addFactorVectorized method can be called once to create many factors.

.Vectorizing over all variables

In this first example, we create three variable matrices and generate 12 factors connecting a(i,j), b(i,j), and c(i,j) for all i and j.

----
fg = FactorGraph();
a = Bit(3,4);
b = Bit(3,4);
c = Bit(3,4);
fg.addFactorVectorized(@xorDelta,a,b,c);
----

.Specify Vectorize Dimensions

By default addFactorVectorized will add factors for every dimension.  However, if a user wants to only vectorize over a subset of dimensions, addFactorVectorize
allows them to provide a cell array containing a variable matrix as the first argument and a list of dimensions to vectorize over as the second argument.  The following code will vectorize over the first two dimensions to create 12 xor factors.  Each xor factor is connected to 5 bits.

----
fg = FactorGraph();
b = Bit(3,4,5);
fg.addFactorVectorized(@xorDelta,{b,[1 2]});
----

.Connecting a single variable with addFactorVectorized

The addFactorVectorized method will ensure that dimensions being vectorized match for all inputs.  However, the call allows single variables to be connected to many as follows:

----
fg = FactorGraph();
a = Bit(10,1);
b = Bit();
fg.addFactorVectorized(@xorDelta,a,b);
----

This will create a graph such that b is connected to every element of a via a total of 10 factors.

.repmat

Similar things can be done with repmat.  Suppose you have a 10x1 vector of variables that you want connected to a 10x20 matrix of different variables.
The following code will create 200 factors.  Each element of a will be connected to 20 elements of b via 20 factors.

----
fg = FactorGraph();
a = Bit(10,1);
b = Bit(10,20);
fg.addFactorVectorized(@xorDelta,repmat(a,1,10),b);
----

.Constants

Users can still pass constants to addFactor.  The following passes the constant 1 to the xorDelta factor function as the final argument.

----
fg = FactorGraph();
b = Bit(10,3);
fg.addFactorVectorized(@xorDelta,{b 1},1);
----

.Nested Graphs

Nested Graphs are also supported

----
a = Bit(3,1);
ng = FactorGraph(a);
ng.addFactor(@xorDelta,a);
fg = FactorGraph();
b = Bit(10,3);
fg.addFactorVectorized(ng,{b, 1});
----

Setting the Solver
^^^^^^^^^^^^^^^^^^

.Specifying an object

It is possible to switch the solver of an existing model.  An Example:

----
   setSolver(com.lyricsemi.dimple.solvers.sumproduct.Solver());
   fg = FactorGraph();
   b = Bit(3,1);
   fg.addFactor(@xorDelta,b);
   b.Input = [.8 .8 .6];
   fg.NumIterations = 1;
   fg.solve();
   
   expected = [0.7586; 0.7586; 0.4138];
   assertTrue(all((b.Belief-expected)<.0001));
   fg.Solver = com.lyricsemi.dimple.solvers.minsum.Solver();
   fg.NumIterations = 1;
   fg.solve();
   expected = [0.7273; 0.7273; 0.2727];
   assertTrue(all((b.Belief-expected)<.0001));
----

Switching solvers is not currently supported when custom factors are in use, because it will cause errors in two different cases:

Case 1: 

. The user sets a solver that provides a custom factor.
. The user instantiate a graph that uses that custom factor.
. The user switches to a Solver that does not provide that same custom factor.
. The user tries to solve the graph using the new solver.

In step 2, {swname} avoids creating a FactorTable to avoid the overhead of creating something it will not use.  If allowed to get to step 4, {swname} cannot successfully solve because it has neither a FactorTable or a custom factor for one of the nodes of the graph.  {swname} will throw an error at step 3, indicating the problem.

Case 2:

. The user sets a solver that provides no custom factors.
. The user creates a graph
. The user sets a new solver that defines a custom factor for one of the nodes in this graph.
. The user tells {swname} to solve

In this case, {swname} will not use the custom factor or combo table associated with the node, and will throw and error at step 4.

 In the future we might fix some of these issues but, until then, users should only switch solvers in cases where custom factor nodes are not used.

.Using a Name

{swname} has been modified to allow users to register commonly used solvers so that they can be assigned using shorter names. Previously users had to do:

----
setSolver(com.lyricsemi.dimple.solvers.sumproduct.Solver());
fg = FactorGraph();
----

or

----
fg = FactorGraph();
fg.Solver = com.lyricsemi.dimple.solvers.sumproduct.Solver();
Users can now do:
setSolver('SumProduct'); 
fg = FactorGraph();
----

or

----
fg = FactorGraph();
fg.Solver = 'SumProduct';
----

For solvers that take constructor arguments, users can use the setSolver command:

----
fg = FactorGraph();
fg.setSolver('Gibbs',param1,param2,param3,param4);
----

or

----
setSolver('Gibbs',param1,param2,param3,param4);
----

For a full list of registered solvers, type:

----
getSolverNames()
----

If users wish to register their own solvers they can call:

----
registerSolver(solverName,solverConstructor);
----

And if they wish to unregister a solver they can call:

----
unregisterSolver(solverName);
----

addGraph
^^^^^^^^

----
MyGraph.addGraph(NestableGraph,Vars);	
----

The addGraph method creates a copy of the nestable factor graph, and connects the connector variables to the input variables of the addGraph method.

NumIterations
^^^^^^^^^^^^^

----
MyGraph.NumIterations=30;
----

The NumIterations method sets the number of iterations BP is going to run for. It is desirable to set a positive value before running solve, as the default value is 0.

Solve
^^^^^

The solve command calls the java solver and runs BP on the factor graph for the desired number of iterations, using a flooding schedule.

Modifying an existing graph
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Removing a Factor

It’s possible to remove a Factor from a FactorGraph:

----
fg = FactorGraph();
   b = Bit(3,1);
   fg.addFactor(@xorDelta,b(1:2));
   f = fg.addFactor(@xorDelta,b(2:3));
   b.Input = [.8 .8 .6];
   fg.NumIterations = 2;
   fg.solve();
   assertElementsAlmostEqual([.96 .96 .96]',b.Belief);
   fg.removeFactor(f);
   fg.solve();
   p1 = .8*.8;
   p0 = .2*.2;
   total = p1+p0;
   p1 = p1/total;
   p0 = p0/total;
   assertElementsAlmostEqual([p1 p1 .6]',b.Belief);
----

.Splitting Variables

It can be useful to make a copy of a variable and relate it to the old variable with an equals factor. The following code shows how to do this.

----
   a = Bit();
   a.Name = 'a';
   b = Bit();
   b.Name = 'b';
  
   fg = FactorGraph();
  
   f = fg.addFactor(@(x,y) x~=y,a,b);
   f.Name = 'unequal';
   
   b2 = fg.split(b);
   b2.Name = 'b2';
   a2 = fg.split(a,f);
   a2.Name = 'a2';
   
   fg.plot(1);
----

We've added code to name all the variables and factors so that the following plot is informative.

image:images/SplitGraph.png["split graph",height=300]
 
Note that the split method takes a list of factors as the second through nth argument. This is the list of factors that will be moved from the original variable to the copied variable. All unspecified factors will remain connected to the initial variable.

.Joining Variables

Users can now join variables. This will create a new joint variable and modify all factors connected to the original variables to reconnect to the new joint variable. This can be useful in eliminating loops in a graph. The following code creates a loopy graph and then uses join to remove the loop.

----
a = Bit(); 
a.Name = 'a'; 
b = Bit();
b.Name  = 'b';
c = Bit();
c.Name = 'c';
d = Bit();
d.Name = 'd';

fg = FactorGraph();
f1 = fg.addFactor(@xorDelta,a,b,c);
f1.Name = 'xor';
f2 = fg.addFactor(@(x,y,z) (x|y)==z ,a,b,d);
f2.Name = 'or';
 
newvar = fg.join(a,b);
newvar.Name = 'a,b';

fg.plot(1);
----

The following is the loopy graph:

image:images/LoopyGraph.png["Loopy Graph",height=200]
  
And after joining the variables we have:

image:images/NonLoopyGraph.png["Non Loopy Graph",height=300]

.Joining Factors
Users can also join factors. It is possible to remove loops by joining factors as well as by joining variables.

----
   b = Bit(4,1);
   for i = 1:4
       b(i).Name = sprintf('b%d',i);
   end
   fg = FactorGraph();
   f1 = fg.addFactor(@xorDelta,b(1:3));
   f2 = fg.addFactor(@xorDelta,b(2:4));
   
   f3 = fg.join(f1,f2);
   f3.Name = 'twoxors';
   
   b.Input = input;
   fg.solve();
   actualBelief = b.Belief;
   
   fg.plot(1);
----

The following plot shows the graph with the loops:  
 
image:images/LoopyGraph2.png["loopy graph",height=200]

And the following plot shows the graph after the factor is joined: 
 
image:images/NonLoopyGraph2.png["Non loopy graph 2",height=200]

To join factors, {swname} does the following:

* Find the variables in common between two factors.
* Take the cartesian product of the tables but discard rows where the common variable indices differ.
* Consolidate the columns with common variables.
* Multiply the values for each row.

Custom Schedules
^^^^^^^^^^^^^^^^

{swname} supports user defined custom schedules created in MATLAB.
The following code demonstrates that feature:

----
   eq = @(x,y) x == y;
   fg = FactorGraph();
   a = Bit();
   b = Bit();
   c = Bit();
   eq1 = fg.addFactor(eq,a,b);
   eq2 = fg.addFactor(eq,b,c);
   
   %define schedule
   % update b
   % update eq1->a
   % update eq2->c
   % update a->eq1
   % update c->eq2
   % update eq1->b
   % update eq2->b
   schedule = {
       b,
       {eq1,a},
       {eq2,c},
       {a,eq1},
       {c,eq2},
       {eq1,b},
       {eq2,b}
       };
   
   fg.Schedule = schedule;
   
   %Set priors
   a.Input = .6;
   b.Input = .7;
   c.Input = .8;
   
   %Solve
   fg.NumIterations = 1;
   fg.solve();
----

{swname} also supports nesting custom schedules and nesting in general. The following example demonstrates specifying nested graphs in a schedule.

----
   eq = @(x,y) x == y;
   b = Bit(2,1);
   nfg = FactorGraph(b);
   nfg.addFactor(eq,b(1),b(2));
   b = Bit(3,1);
   fg = FactorGraph();
   nf1 = fg.addFactor(nfg,b(1),b(2));
   nf2 = fg.addFactor(nfg,b(2),b(3));
   
   
   fg.Schedule = {b(1),nf1,b(2),nf2,b(3)};
   b(1).Input = .7;
   fg.NumIterations = 1;
   fg.solve();
----

And finally we look at nesting a custom schedule:

----
   %Now let's try nesting with a custom schedule on the nested graph.
   
   %Create a graph to nest and give it a funny schedule    
   % nfg: eb(1) - f1 - ib - f2 - eb(2)
   eb = Bit(2,1);
   ib = Bit();
   nfg = FactorGraph(eb);
   f1 = nfg.addFactor(eq,eb(1),ib);
   f2 = nfg.addFactor(eq,ib,eb(2));
   %Set an input and solve
   eb(1).Input = .8;
   
   nfg.NumIterations = 1;
   nfg.solve();
   
   %We expect the output to be equal to the input since the tree
   %scheduler passes the info along.
   assertElementsAlmostEqual(eb(2).Belief,eb(1).Input(1));
   
   %Now we create a schedule that will not propagate the info.
   nfg.Schedule = {ib,{f1,eb(1)},{f2,eb(2)},eb(1),eb(2),f1,f2};
   nfg.solve();
   
   assertElementsAlmostEqual(eb(2).Belief,.5);

   %Nest it and see if the schedule is preserved
   b = Bit(2,1);
   fg = FactorGraph();
   g = fg.addFactor(nfg,b);
   
   fg.Schedule = {b(1),b(2),g};
   
   b(1).Input = .8;
   fg.NumIterations = 1;
   fg.solve();
   assertElementsAlmostEqual(b(2).Belief,.5);
----

Explicit Scheduling and Retrieving Message Values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{swname} supports the ability to retrieve and set messages as well as to explicitly update edges, factors and variables.

----
%OK, first we create a simple Factor Graph with a single xor connecting two  
%variables.
fg = FactorGraph(); 
b = Bit(2,1);
f = fg.addFactor(@xorDelta,b);
%We can go ahead and set some inputs
b(1).Input = .8;
b(2).Input = .7;


%we can examine some edges 
disp(f.Ports{1}.InputMsg);
disp(f.Ports{1}.OutputMsg);

%we can even set some edge messages
f.Ports{1}.InputMsg = [.6 .4];

%we can update a node 
b(1).update();
b(2).update();

%or all the variables in a vector.
b.update();

%or a specific edge
b(1).updateEdge(f);
 
%but updating via portNum is quicker
b(1).updateEdge(1);

%of course, if we don't know the portNum, we can get it
portNum = b(1).getPortNum(f);
b(1).updateEdge(portNum);

%We can do the same kind of stuff with factors
f.updateEdge(b(1));
f.updateEdge(f.getPortNum(b(2)));

%Let's look at some messages again
b(1).Ports{1}.InputMsg
b(2).Ports{1}.InputMsg

%and some beliefs
b.Belief
----

Plotting
^^^^^^^^

When debugging Factor Graphs, it is sometimes useful to be able to plot a Factor Graph.  The FactorGraph class provides a plot method that can be used to visualize a Factor Graph.

The following code describes how to use the plot function in various ways.

----
%First we build a Factor Graph to use for plotting examples
fg = FactorGraph();
b = Bit(6,1);
for i = 1:6
    b(i).Name = sprintf('b%d',i);
end
 
%We use Label rather than Name for the factors so that we can assign
%them the same Label.  Name must be a unique identifier,
%Label is just used for printing/plotting.
f1 = fg.addFactor(@xorDelta,b(1:4));
f1.Label = 'f';
f2 = fg.addFactor(@xorDelta,b(4:6));
f2.Label = 'f';
 
 
pause_time = 1;
 
%Calling plot with no arguments shows no labels.  It draws variables as
%circles and factors as squares.
fg.plot();
----

This will result in the following graph:

image:images/plot1.png["plot 1",height=200]

Note that factors are displayed as squares and variables as circles.

----
pause(pause_time);
 
%The following is equivalent to the previous plot command.  We are simply
%explicitly turning off labels.
fg.plot('labels',false);
----

Results in the same plot as above.

----
pause(pause_time);
 
%Now we turn on the labels.  Now we see the names we assigned to the
%various nodes and variables of the Factor Graph.
fg.plot('labels',true);
----

Results in the following:
 
image:images/plot2.png["plot 1",height=200] 

If the user has specified a Label, those will be displayed, otherwise the object’s Name’s will be displayed.

----
pause(pause_time)
 
%We can specify a subset of nodes to plot
fg.plot('labels',1,'nodes',{b(1:2),f1});
----

Results in the following:
 
image:images/plot3.png["plot 1",height=200]

Only the specified nodes and their connectivity were included.

----
pause(pause_time)
 
%By can set a global color for all the nodes in the graph.
fg.plot('labels',1,'color','g');
----

Setting a global color:

image:images/plot4.png["plot 1",height=200] 

----
pause(pause_time)
 
%We can specify a color for one node in the graph.
fg.plot('labels',1,'nodes',{b(1:2),f1},'color',b(1),'g');
----

Setting a color for a specific node:
 
image:images/plot5.png["plot 1",height=200]
 
----
pause(pause_time)
 
%We can specify colors for multiple nodes in the graph.
fg.plot('labels',1,'nodes',{b(1:2),f1},'color',{b(2),f1},{'r','c'});
----

Setting colors for multiple nodes:

image:images/plot6.png["plot 1",height=200]

----
pause(pause_time)
 
%We can mix setting a global color, colors for a single node mutliple
%times, and colors for multiple nodes.  The global color is used in all
%cases where a color has not explicitly been set for a node.
fg.plot('labels',1,'color',b(1),'g','color',b(2),'r','color',{b(3),b(4)},{'y','c'},'color','b');
----

Mixing and matching the various coloring options:

image:images/plot7.png["plot 1",height=200]

----
pause(pause_time)
 
%We can also specify a root node on which we perform a depth first search
%up to a specific depth and then only print nodes up to that depth.
for depth = 0:5
 
    %Furthermore, we color the root node green so we know which is the root
    %node.
    fg.plot('labels',1,'depth',b(1),depth,'color',b(1),'g','color','b');
    
    pause(pause_time);
end
----

Specifying a depth will display a specified root node and all nodes that are N steps away.  The following shows the result of calling plot with ‘depth’ of b(1) and 2:
 

image:images/plot8.png["plot 1",height=200]

We also colored the root node green to make it clear which was the root node.

----
%The following shows how using the depth feature we might be able to find
%out interesting information.  Here we increase the depth until we visually
%see a loop.
[ldpc,vars] = createLDPC();
v = vars(1);
 
for depth = 0:6
    ldpc.plot('depth',v,depth);
    
    pause(pause_time);
end
----

Here, we show how we can use plot to find interesting information about a large graph.  The final plot with a depth of 6 shows a cycle in an LDPC Factor Graph:

image:images/plot9.png["plot 1",height=200]

 
.Nesting

By default, the plotting method ignores hierarchy and plots the flattened graph.  If the user specifies the 'nesting' parameter, however, they can specify how deep to descend into the hierarchy before considering NestedGraphs to be Factors and plotting them as such.

When labels are turned off, nested graphs are displayed as triangles

First let's build a graph with three levels of nesting.

----
b = Bit(2,1);
template1 = FactorGraph(b);
iv = Bit();
template1.addFactor(@xorDelta,b(1),iv);
template1.addFactor(@xorDelta,b(2),iv);
 
b = Bit(2,1);
template2 = FactorGraph(b);
iv = Bit();
template2.addFactor(template1,b(1),iv);
template2.addFactor(template1,b(2),iv);
 
template2.plot();
 
b = Bit(2,1);
fg = FactorGraph(b);
iv = Bit();
fg.addFactor(template2,b(1),iv);
fg.addFactor(template2,b(2),iv);
----
 
Here we show the graph plotted with various levels of nesting.

fg.plot('nesting',0);

image:images/plot10.png["plot 1",height=200]

Notice the Nested Graphs show up as triangles.

----
fg.plot('nesting',1);
----

image:images/plot11.png["plot 1",height=200]
 
----
fg.plot('nesting',2);
----

image:images/plot12.png["plot 1",height=200]
 
Note that once we’ve reached the bottom, we’re actually seeing the Factors plotted.
 
We can retrieve an instance of a nested graph and plot that with nesting set.

----
fg.NestedGraphs{1}.plot('nesting',0);
pause(pause_time);
----

image:images/plot13.png["plot 1",height=200]
 
 
When plotting graphs, boundary variables show up as stars.

Next we mix depth first search with nesting

----
fg.plot('nesting',0,'depth',iv,0);
----
image:images/plot14.png["plot 1",height=200]
 
----
fg.plot('nesting',0,'depth',iv,1);
----

image:images/plot15.png["plot 1",height=200]
 
----
fg.plot('nesting',0,'depth',iv,2);
----

image:images/plot16.png["plot 1",height=200]

Energy
^^^^^^^

Bethe Free Energy

[latex]
\[
BetheFreeEnergy = InternalEnergy - BetheEntropy
\]

----
bfe = fg.BetheFreeEnergy;
----

Internal Energy

[latex]
$ InternalEnergy = \sum_{a \in F }InternalEnergy(a) + \sum_{i \in V}InternalEnergy(i) $

Where F is the set of all Factors and V is the set of all variables.  If Dimple treated inputs as single node Factors, this method would only sum over factors.

----
ie = fg.InternalEnergy;
----

Bethe Entropy

[latex]
$ BetheEntropy = \sum_{a \in F}BetheEntropy(a) - \sum_{i \in V}BetheEntropy(i)(degree(i)-1) $

Where F is the set of all Factors and V is the set of all variables.

----
be = fg.BetheEntropy;
----

Factor Internal Energy

[latex]
$ InternalEnergy(a) = \sum_{\vec{x} \in \vec{X}}B_a(\vec{x})*(-log(Weight(\vec{x}))) $

Where a is an instance of a Factor, X is the set of variables connected to a, Weight is the FactorTable entry for the specified set of variable values, and B~a~ is the belief of that factor node.

----
ie = f.InternalEnergy;
----

Factor Bethe Entropy

[latex]
$ BetheEntropy(a) = - \sum_{\vec{x} \in domain(\vec{X})}B_a(\vec{x})*log(B_a(\vec{x})) $

Where a is an instance of a Factor, X is the set of variables connected to a, and B~a~ is the belief of that factor node.

----
be = f.BetheEntropy;
----

Variable Internal Energy

[latex]
$ InternalEnergy(i) = \sum_{d \in D}B_i(d)*(-log(Input(d))) $

Where D is variable i's domain and Input is the variable's input.

----
ie = v.InternalEnergy;
----

Variable Bethe Entropy

[latex]
$ BentheEntropy(i) = - \sum_{d \in D}B_i(d)*log(B_i(d)) $

Where D is variable i's domain.

----
be = v.BetheEntropy();
----

Factor Belief

To support the Bethe Free Energy property, Dimple provides getBelief associated with a Factor.

[latex]
$ B_a(\vec{x}) = \frac{Weight(\vec{x})\prod_{i=0}^N \mu_{X_i \rightarrow a}(x_i)}{\sum_{\vec{x} \in \vec{X}}Weight(\vec{x})\prod_{i=0}^N \mu_{X_i \rightarrow a}(x_i\
)} $

Where 

[latex]
\vec{x} \in domain(\vec{X})

and 

\vec{X}

is the set of variables connected to the factor a.

----
b = f.Belief;
----

Score

Users can retrieve the Energy of a Factor Graph, Variable Vector, or Factor. This feature is currently only supported with the SumProduct algorithm.

The following are examples of ways to retrieve the energy of FactorGraphs, factors, and variables:

----
fg = FactorGraph();
b = Bit(3,1);
f = fg.addFactor(@xorDelta,b);

fg.Score
f.Score
b.Score
b(1).Score
----

When computing the score, the most likely variable value is used. It's possible to override that by setting a guess on a variable using:

----
b.Guess = 1; %For other variable types, var.Guess takes a domain item.
----

.Math behind the score
The variable energy is normalized by the maximum input probability.

[latex]
$ score(v) = -log(inputProb(guess) + log(max(inputProb)) $

The factor energy is normalized by the largest factor value.

[latex]
$  score(f) = −log(f(guessxguessyguessz))+log(max(f)) $

And the Factor Graph’s energy is as follows:

[latex]
$ score(fg) = \sum_{v \in V} score(v) + \sum_{f \in F} score(f) $

Introspection
^^^^^^^^^^^^^^

The FactorGraph class provides several feature for inspecting aspects of the graph.  The ability to nest graphs complicates things a bit.  Nested FactorGraphs can be considered Factors.  All of the introspection features allow the user to view nested graphs as leaf factors or to descend into them and operate on the children of the nested graphs.  Each feature provides several methods:

* <FeatureName>(int relativeNestingDepth) – The relativeNestingDepth specifies how deep to descend into the nested FactorGraphs before treating deeper NestedGraphs as Factors.  Specifying 0 will treat the top level nested Graphs as factors.  Specifying a large enough number will descend all the way to the leaf factors.  Specifying something inbetween 0 and the FactorGraph’s maximum depth will descend as far as this parameter specifies before considering NestedGraphs to be factors.  The parameter contains the word “relative” because users can retrieve nested graphs.  They can call one of the feature’s methods on that nested graph.  
* <FeatureName>Flat() – equivalent of <FeatureName>(max int)
* <FeatureName>Top() – equivalent of <FeatureName>(0)
* <FeatureName() – equivalent of <FeatureName>Flat().  It was thought that users will most often want to operate on the FactorGraph in its flattened form.

Now, on to the specific features.

.Retrieving All Factors

Users can retrieve Factors and/or NestedGraphs associated with a graph using the Factors methods and properties:

* Fg.Factors
* Fg.FactorsFlat
* Fg.FactorsTop
* Fg.getFactors(relativeNestingDepth)

When the user specifies a relativeNestingDepth or calls FactorsTop, the resulting cell array will contain a mix of leaf factors and Nested Graphs.

.Retrieving Factors but not Nested Factor Graphs

The FactorGraph class provides the following:

* NonFactorGraphFactors
* NonFactorGraphFactorsFlat
* NonFactorGraphFactorsTop
* getNonFactorGraphFactors(relativeNestingDepth)

As the name implies, this will behave similar to the Factors properties and methods but will exclude nested graphs.

.Retrieving Variables

The FactorGraph class provides the following:

* Variables – calls VariablesFlat
* VariablesFlat – Returns a list of all the Variables in the graph, including those contained by nested graphs.
* VariablesTop – Returns only those variables contained in the top level of the graph.
* getVariables(relativeNestingDepth,forceIncludeBoundaryVariables) – Returns all variables contained in the FactorGraph from which the method is called as Variables that are as deep as the specified relativeNestingDepth.  The second parameter is optional and defaults to false.  When false, boundary variables are only included by the root graph.  When true, boundary variables are included regardless of whether a graph is a root or nested graph.

.Retrieving all Nodes

The FactorGraph provides the following:

* Nodes
* NodesFlat
* NodesTop
* getNodes(relativeNestingDepth,forceIncludeBoundaryVariables)

These methods call the Factor and Variable methods and concatenate the results together.

.Determining if a FactorGraph is a tree.

The FactorGraph class provides the following:

* isTree(relativeNestingDepth) 
* isTreeTop 
* isTreeFlat 

isTree – Users can call <factor graph name>.isTree() to determine if a FactorGraph is a tree.  If the graph contains cycles, this method will return false. Like the other methods, the relativeNestingDepth determines at what point to consider NestedGraphs to be leaf cells.  

.Retrieving an Adjacency Matrix

All of the following methods return a pair: [A, labels] where A is a square connectivity matrix and labels is a cell array of strings specifying the names of the nodes in A. 

* getAdjacencyMatrix(relativeNestingDepth,forceIncludeBoundaryVariables) – relativeNestingDepth behaves the same as in other methods that take this parameter.  So does forceIncludeBoundaryVariables. forceIncludeBoundaryVariables has a default value of false.
* getAdjacencyMatrix(nodes,forceIncludeBoundaryVariables) – Users can specify a specific subset of nodes in which they’re interested.  This method will return an adjacency matrix with only those nodes.  Nodes are considered connected only if there is an edge directly connecting them.
* getAdjacencyMatrixTop() – equivalent to getAdjacencyMatrix(0,false)
* getAdjacencyMatrixFlat() – equivalent to getAdjacencyMatrix(intmax,false)

FactorGraph also provides an AdjacencyMatrix Property:

* AdjacencyMatrix – equivalent to getAdjacencyMatrixFlat and only returns A (not the labels).  MATLAB properties can only return one object.

An example of getAdjacencyMatrix:

----
fg = FactorGraph();
b = Bit(2,1);
b(1).Name = ‘b1’;
b(2).Name = ‘b2’;
f = fg.addFactor(@xorDelta,b);
f.Name = ‘f’;
[A,labels] = fg.getAdjacencyMatrix();
A =

     0     0     1
     0     0     1
     1     1     0


labels = 

    'b1'
    'b2'
    'f'
----

.Depth first search

* depthFirstSearch(node, searchDepth, relativeNestingDepth) – 
** node – Specifies the node from which to initiate the search
** searchDepth – specifies how far from “node” the search should go.
** relativeNestingDepth – determines how deep to go down the NestedGraphs before considering NestedGraphs to be leaf cells. 
* depthFirstSearchFlat(node, searchDepth) – equivalent of depthFirstSearch(node,searchDepth,maxint)
* depthFirstSearchThop(node, searchDepth) – equivalent of depthFirstSearch(node,searchDepth,0)

An example:

----
fg = FactorGraph();
b = Bit(6,1);
for i = 1:6
b(i).Name = sprintf('b%d',i);
end
f1 = fg.addFactor(@xorDelta,b(1:4));
f1.Name = 'f1';
f2 = fg.addFactor(@xorDelta,b(4:6));
f2.Name = 'f2';
 
nodes = fg.depthFirstSearch(b(1),3);
----

calling fg.plot(‘color’,b(1),’g’,’labels’,true) reveals the following structure of this graph

image:images/Introspection.png["Introspectin",height=200]
 
As you might guess fg.depthFirstSearch(b(1),3) will return a collection of six nodes: b1, f1, b2, b3, b4, and f2.  It will not include b5 and b6 since those are at a depth of four from b1.

Estimating Parameters
^^^^^^^^^^^^^^^^^^^^^

Dimple provides support for estimating parameters.  Only the sumproduct solver currently supports this. 
The sum product algorithm computes the gradient of the BetheFreeEnergy and performs a gradient descent on this.  Users can
specify how many times to restart the gradient descent with random table values.

Users provide four arguments:

* factorsAndFactorTables - A cell array of FactorTables for which the user wants parameters to be estimated.  They can mix Factors and FactorTables
* numRestarts - The number of times to randomly initialize the FactorTables and restart the gradient descent.
* numSteps - The number of times to descend down along the gradient
* stepScaleFactor - The value we scale the gradient by.

----    
fg.estimateParameters({factorTable1,factorTable2,factor1,etc...},numRestarts,numSteps,stepScaleFactor);
----

Factor
~~~~~~

It is possible to retrieve a Factor object in a number of ways:

----
factor = fg.addFactor(@xorDelta,b);
factors = fg.Factors;
factors = b.Factors;
%other ways specified in the introspection section.
----


The Factor object provides methods for inspecting as well as modifying the Factor Graph.

Changing FactorTables
^^^^^^^^^^^^^^^^^^^^^

FactorTables are shared between factors. A change a combo table for one factor and that combo table is shared by another factor, you are changing it globally. 

The following unit test shows how to use this feature:

----
function testChangeFactorTable()
   %Create a Factor Grap
   fg = FactorGraph();
   
   %Create 6 bits
   b1 = Bit(3,1);
   b2 = Bit(3,1);
   
   %Create two factors that are independent from one another.
   %We do this so that we can show that changing one factor's
   %combo table affects the other factor.
   f1 = fg.addFactor(@xorDelta,b1);
   f2 = fg.addFactor(@xorDelta,b2);
   
   fg.NumIterations = 1;
   fg.solve();
   %First, make sure we get 50% for all variables.
   assertElementsAlmostEqual([.5 .5 .5]',b1.Belief);
   assertElementsAlmostEqual([.5 .5 .5]',b2.Belief);
   %Now we change the values
   newvals = [1 2 3 4]';
   f1.FactorTable.Values = newvals;
   %Solve
   fg.solve();
   %Now we want to check that the result is correct
   indices = f1.FactorTable.Indices;
   
   %Since we've left the input as 50%, we can use a trick
   %where we multiply the values against the indices for each variable
   %to get the expected belief
   p0s = double(indices)'* newvals;
   p1s = double(~indices)'* newvals;
   total = p0s + p1s;
   p1s_normalized = p1s ./ total;
   %compare
   assertElementsAlmostEqual(p1s_normalized,b1.Belief);
   assertElementsAlmostEqual(p1s_normalized,b2.Belief);
   %Now we try changing the indices.  This is basically an inverted
   %xor.
   f1.FactorTable.Indices = ~indices;
   fg.solve();
   %we expect the probabilities to be inverted.
   assertElementsAlmostEqual(1-p1s_normalized,b1.Belief);
   assertElementsAlmostEqual(1-p1s_normalized,b2.Belief);

   %Try changing the combo table completely.  here we turn it
   %into an equals gate.
   f1.FactorTable.change([0 0 0; 1 1 1],[1 1]);
   b1(1).Input = .8;
   b2(1).Input = .8;
   
   fg.solve();
   
   assertElementsAlmostEqual([.8 .8 .8]',b1.Belief);
   assertElementsAlmostEqual([.8 .8 .8]',b2.Belief);
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %Let's test our ability to catch errors
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   %First we try this when the user sets the value vector to a bad length
   thrown = 0;
   try
       f1.FactorTable.Values = [1 2 3];
   catch exception
       thrown = 1;
   end
   assertTrue(thrown==1);
   %Next we try setting the indices to an incorrect length
   thrown = 0;
   try
       f1.FactorTable.Indices = ones(3,3);
   catch exception
       thrown = 1;
   end
   assertTrue(thrown==1);
   %Set indices to values that are too large for the domain lengths
   thrown = 0;
   try
       f1.FactorTable.Indices = ones(2,3)*2;
   catch exception
       thrown = 1;
   end
   assertTrue(thrown==1);
end
----

Factor Belief
^^^^^^^^^^^^^

Users can retrieve beliefs from Factors. As demonstrated in this unit test:

----
function output = funkyFactor(x,y,z)
   if x == y && y == z
       if x == 0
           output = 1;
       else
           output = 2;
       end
   else
       output = 0;
   end
end
    %Create a Factor Graph
       b = Bit(3,1);
       fg = FactorGraph();
       f = fg.addFactor(@funkyFactor,b(1),b(2),b(3));
       
       %Set inputs
       input = [.8 .8 .6];
       b.Input = input;
       %We have to solver right now
       fg.Solver.setNumIterations(1);
       fg.solve();
       %funkyFactor only allows these two combos.
       expectedDomain = {0,0,0;1,1,1};
       assertEqual(expectedDomain,f.Domain);
       %Bit stores values as 1,0.
       expectedIndices = int32([2,2,2;1,1,1]);
       assertEqual(expectedIndices,f.Indices);
       %Let's calculate the belief by hand and compare to {swname}.
       val0 = prod(1-input)*funkyFactor(0,0,0);
       val1 = prod(input)*funkyFactor(1,1,1);
       total = val0 + val1;
       val0 = val0 / total;
       val1 = val1 / total;
       expectedBelief = [val0; val1];
       assertElementsAlmostEqual(expectedBelief,f.Belief);
       %Now we create a full belief and compare to our expected.
      expectedFullBelief = zeros(2,2,2);
       expectedFullBelief(1,1,1) = val1;
       expectedFullBelief(2,2,2) = val0;
       assertElementsAlmostEqual(expectedFullBelief,f.FullBelief);
----

Setting Directionality of a Factor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Some solver features require knowledge of factor directionality.  Users can set directionality of a factor with the FactorTo property.
This property expects a cell array containing a comma separated list of variables the factor is directed towards.  When directionality is set, if 
a FactorTable exists, Dimple will check to ensure the factor is normalized properly.  

----
fg = FactorGraph();
b = Bit(3,1);
f = fg.addFactor(@xorDelta,b);
f.DirectedTo = {b(1), b(2)};
----

Users can also specify variable matrices.  The above is equivalent to:

----
f.DirectedTo = {b};
----

Dimple provides the ability to pass a variable directly as well:

----
f.DirectedTo = b;
----

Also, DirectedTo works with addFactorVectorized.  Users must ensure the variable dimensions match the factor dimensions.  The following
create a Markov Model.

----
fg = FactorGraph();
s = Discrete(states,N);
fg.addFactorVectorized(@transitionFunction,s(1:(end-1)),s(2:end)).DirectedTo = s(2:end);
----

More complicated vectorizations are possible.  The following creates 12 factors, each of which contains 10 variables (5 from a and 5 from b).
The first 2 of the 5 from a and the first from b are what the factor is directed to.

----
fg = FactorGraph();
a = Bit(3,4,5);
b = Bit(3,4,5);
fg.addFactorVectorized(@somefactor,{a, [1 2]}, {b, [1 2]}).DirectedTo = {a(:,:,1:2), b(:,:,1)};
----

General Features
~~~~~~~~~~~~~~~~

User Specified Names
^^^^^^^^^^^^^^^^^^^^

It can be useful to let users specify explicit names for variables, factors, and factor graphs.  The following demonstrates how to do this:

----
 fg = FactorGraph();
 fg.Name = ‘MyFactorGraph’;
 a = Bit();
 b = Bit();
 a.Name = 'a';
 b.Name = 'b';
 f = fg.addFactor(@xorDelta,a,b);
 f.Name = 'f';
----

Solvers
~~~~~~~

Sum Product
^^^^^^^^^^^

The Sum Product solver only supports discrete variables.

Damping
+++++++

The sum product solver supports setting damping:

--------------------------------
fg.Solver.setDamping(dampingVal);
--------------------------------



K Best
++++++

The sum product solver supports a k-best algorithm.  Users can set a K value on 
each factor:

-----------------------
fg = FactorGraph();
vars = Discrete(1:D,NumVars,1);
f = fg.addFactor(factorFunction,vars);
f.Solver.setK(K);
vars.Input = 1:D;
fg.solve();
-------------------------

The solver will only use the k-best values for each variable when calculating output messages
on a factor node.

IMPORTANT: k-best and damping are not yet compatible.

Min Sum
^^^^^^^^

The Min Sum solver only supports discrete variables.  Like Sum Product, Min Sum supports both damping
and k-best.

Particle BP
^^^^^^^^^^^
.API

.Basic Constructor

The basic constructor for the Particle BP solver is:

----
com.lyricsemi.dimple.solvers.particleBP.Solver()
----

.Methods

The following sections list the solver-specific methods for the Particle BP solver (MATLAB versions).

.Graph Methods

----
graph.Solver.setNumParticles(numParticles);
----

For each variable in the graph, sets the number of particles per variable. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

----
graph.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
----

For each variable in the graph, sets the number of updates per particle to perform each time the particle is resampled. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

----
graph.Solver.setNumIterationsBetweenResampling(numIterationsBetweenResampling);
graph.Solver.getNumIterationsBetweenResampling();
----

Set/get the number of iterations between re-sampling all of the variables in the graph (default is 1, meaning resample between every iteration).

----
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
----

Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

----
graph.Solver.setTemperingHalfLifeInIterations();
graph.Solver.getTemperingHalfLifeInIterations();
----

Set/get the tempering half-life—the number of iterations for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

----
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
----

Enable or disable the use of tempering, or determine if tempering is in use.

----
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
----

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

----
graph.Solver.setSeed(seed);
----

Set the random seed used for re-sampling. Setting the seed allows repeatable execution of the solver.

.Variable Methods

The Particle BP solver supports both discrete and real variables. For discrete variables, the solver uses sum-product BP as normal, and all of the corresponding methods for the sum-product solver may be used for discrete variables. For real variables, several solver-specific methods are defined, as follows.

.Real-Variable-Specific Methods

----
variable.Solver.setNumParticles(numParticles);
variable.Solver.getNumParticles();
Set/get the number of particles to represent this variable.
variable.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
variable.Solver.getResamplingUpdatesPerParticle();
Set/get the number of updates per particle to perform each time the particle is resampled.
variable.Solver.setProposalStandardDeviation(stdDev);
variable.Solver.getProposalStandardDeviation();
Set/get the standard deviation for a Gaussian proposal distribution (the default is 1).
variable.Solver.setInitialParticleRange(min, max);
----

Set the range over which the initial particle values will be defined. The initial particle values are uniformly spaced between the min and max values specified. If the range is specified using this method, it overrides any other initial value. Otherwise, if a finite domain has been specified, the initial particle values are uniformly spaced between the lower and upper bound of the domain. Otherwise, all particles are initially set to zero.

----
variable.Solver.getParticleValues();
----

Returns the current set of particle values associated with the variable.

----
variable.Solver.getBelief(valueSet);
----

Given a set of values in the domain of the variable, returns the belief evaluated at these points. The result is normalized relative to the set of points requested so that the sum over the set of returned beliefs is 1.

NOTE: the generic variable method Belief (or getBeliefs() with no arguments) operates similarly to the discrete-variable case, but the belief values returned are those at the current set of particle values. Note that this representation does not represent a set of weighted particles. That is, the particle positions are distributed approximately by the belief and the belief values represent the belief. It remains to be see if this should be the representation of belief that is used, or if an alternative representation would be better. The alternative solver-specific getBelief(valueSet) method allows getting the beliefs on a user-specified set of values, which may be uniform, and would not have this unusual interpretation.

.Schedulers

Since Particle BP is a form of BP, any of the schedulers for BP can be used for Particle BP.

.Some possible extensions

Can potentially speed performance by in the real factors, caching the dynamically generated combo-table until the particle values change on at least one edge. The resamplingVersionfield of the ParticleBPSolverVariableToFactorMessage is intended to be used to allow the factor to determine whether or not any particle values have changed since they were last used.

Gibbs
^^^^^^

.API

.Constructor

.Basic Constructor

The basic constructor for the Gibbs solver is:

----
com.lyricsemi.dimple.solvers.gibbs.Solver()
----

.Optional Constructor Arguments

There are two optional constructors that allow specifying some of the solver configuration parameters up front. These are:

----
com.lyricsemi.dimple.solvers.gibbs.Solver(burnInUpdates, updatePerSample)
----

and

----
com.lyricsemi.dimple.solvers.gibbs.Solver(burnInUpdates, updatePerSample, initialTemperature, temperingHalfLifeInSamples)
----

The arguments of these constructors are defined as follows:

* burnInUpdates is the number of single-variable updates for the burn-in phase. This is zero by default.
* updatePerSample is the number of single-variable updates per sample. This is one by default. The state of the graph between samples is ignored for the purposes of saving samples and calculating beliefs.
* initialTemperature is the initial temperature for using tempering. This is one by default.
* temperingHalfLifeInSamples is the number of samples for the temperature to drop by half when annealing.

Note that when the second constructor is used, tempering is automatically enabled. It is otherwise disabled by default.

.Methods

All existing {swname} methods work more-or-less as normal, but in some cases the interpretation is slightly different. For example, the .Belief method for a discrete variable returns an estimate of the belief based on averaging over the sample values.

NOTE: The setNumIterations() method is not supported by the Gibbs solver as the term "iteration" is ambiguous in this case. Instead, the method setNumSamples() should be used to set the length of the run. The Solver.iterate() method performs a single-variable update in the case of the Gibbs solver, rather than an entire scan of all variables.

The following sections list the solver-specific methods for the Gibbs solver (MATLAB versions).

.Graph Methods

----
graph.Solver.setNumSamples(numSamples);
graph.Solver.getNumSamples();
----

Set/get the number of samples to be run when solving the graph (post burn-in).

----
graph.Solver.setUpdatesPerSample(updatesPerSample);
graph.Solver.getUpdatesPerSample();
----

Set/get the number of single-variable updates between samples.

----
graph.Solver.setScansPerSample(scansPerSample);
----

Set the number of scans between samples as an alternative means of specifying the sample rate. A scan is an update of the number of variables equal to the total number of variables in the graph. Note that this is relative to the number of variables in the graph at the time of this call, which might be different from the number of variables in the graph when it is solved.

----
graph.Solver.setBurnInUpdates(burnInUpdates);
graph.Solver.getBurnInUpdates();
----

Set/get the number of single-variable updates for the burn-in period prior to collecting samples.

----
graph.Solver.setBurnInScans();
----

Set the number of scans for burn-in as an alternative means of specifying the burn-in period. Note that this is relative to the number of variables in the graph at the time of this call, which might be different from the number of variables in the graph when it is solved.

----
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
----

Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

----
graph.Solver.setTemperingHalfLifeInSamples();
graph.Solver.getTemperingHalfLifeInSamples();
----

Set/get the tempering half-life—the number of samples for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

----
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
----

Enable or disable the use of tempering, or determine if tempering is in use.

----
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
----

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

----
graph.Solver.saveAllSamples();
----

Prior to solving the graph, this method instructs the solver to save all sample values for all variables. Note that this is practical only for relatively small graphs with relatively small number of iterations.

----
graph.Solver.setSeed(seed);
----

Set the random seed used for sampling (and used for random scan, if that schedule is used). Setting the seed allows repeatable execution of the Gibbs solver.

----
graph.Solver.TotalPotential;
----

Returns the total potential over all factors of the graph (including input priors on variables).

.Variable Methods

----
variable.Solver.Sample;
----

Returns the current sample value for a variable.

----
variable.Solver.AllSamples;
----

Returns an array including all sample values seen so far for a variable. Over multiple variables, samples with the same index correspond to the same joint sample value. This method only returns a non-empty value if .saveAllSamples() method had previously been called on the graph or for the variable.

----
variable.Solver.BestSample;
----

Returns the value of the best sample value seen so far, where best is defined as the sample with the minimum total potential over the graph (sum of -log of the factor values and input priors).

----
variable.Solver.saveAllSamples();
----

Prior to solving the graph, this method instructs the solver to save all sample values for this variable.


.Discrete-Variable-Specific Methods

----
variable.Solver.SampleIndex;
----

Returns the index of the current sample for a variable, where the index refers to the index into the domain of the variable.

----
variable.Solver.AllSampleIndices;
----

Returns an array including the indices of all samples seen so far for a variable.

----
variable.Solver.BestSampleIndex;
----

Returns the index of the best sample seen so far.

.Real-Variable-Specific Methods

----
variable.Solver.setProposalStandardDeviation(stdDev)
variable.Solver.getProposalStandardDeviation()
----

Set/get the standard deviation for a Gaussian proposal distribution (the default is 1).

----
variable.Solver.setInitialSampleValue(initialSampleValue)
variable.Solver.getInitialSampleValue()
----

Set/get the initial sample value that is a starting point for the proposal distribution (the default is 0).

.Factor Methods

----
factor.Solver.Potential;
----

Returns the potential value of a factor given the current values of its connected variables.

----
factor.Solver.getPotential(values);
----

Get the potential value of a factor given the variable values specified by the argument vector. The argument must be a vector with length equal to the number of connected variables. For a table-factor (connected exclusively to discrete variables), each value corresponds the index into the domain list for that variable (not the value of the variable itself). For a real-factor (connected to one or more real variables), each value corresponds to the value of the variable.

.Schedulers

There are two schedulers currently defined for the Gibbs solver:

----
com.lyricsemi.dimple.schedulers.GibbsSequentialScanScheduler
----

Sequentially chooses the next variable for updating in a fixed order. It updates all variables in the graph, completing an entire scan, before repeating the same fixed order. (In Gibbs literature this seems to be known as a sequential-scan, systematic-scan, or fixed-scan schedule.)

----
com.lyricsemi.dimple.schedulers.GibbsRandomScanScheduler
----

Randomly selects a variable for each update (with replacement).

The default scheduler when using the Gibbs solver is the GibbsSequentialScanScheduler, which is used if no scheduler is explicitly specified. (Solvers can now define a solver-specific default scheduler, which overrides the overall default scheduler, but can be overridden by a user-specified scheduler.)

.Notes on Implementation

This is a message-based implementation that fits in the existing {swname} architecture, using nearly all the existing {swname} code unchanged. Messages from variables to factors are single values sampled from the domain of the variable. Messages from factors to discrete variables are (unnormalized) conditional distributions over the domain of the variable. Messages from factors to real variables are are indirect—making use of a call-back from the variable to the factor to allow the variable to evaluate the factor's potential for an arbitrary value.

.Some Possible Extensions

* Currently, the table-factor implementation is slow, since it uses the existing combo-tables and scans through the whole table on each run. This could be optimized by precomputing a different table representation that would be more efficient.
* For real-variables, which require connected factors to be defined by custom FactorFunctions, the computation does not use a combo-table, but instead evaluates the factors on-the-fly. The same could be done for discrete-only factors, which in some cases could significantly improve performance and allow factors that would otherwise require a combo-table of impractical size.
* Support adaptive sampling.
* Support other Gibbs schedules.
* Support other annealing schedules, besides exponential decay.

Gaussian Solver
^^^^^^^^^^^^^^^^

.Univariate Gaussian

.High Level View of the Gaussian Solver Math

The Gaussian solver passes means and variances along the Factor Graph edges. It provides two factors that analytically calculate the outgoing messages. The first is a factor for addition and the second is a factor for multiplication by a constant.

Users can create additional factors that use sampling by overriding the GaussianFactorFunction class. The user is required to override two methods: acceptanceRatio and generateSample. These will be described in a later section.

.Creating Variables and a Graph

The Gaussian solver currently works only with real variables. (We will eventually enhance it to work with Discrete variables as well). The following is an example of how to create a Factor Graph that will eventually use the Gaussian solver:

----
a = Real(3,1);
mu = 3;
sigma = 4;
a(1).Input = [mu sigma];  
mu2 = 10;
sigma2 = 2;
a(2).Input = [mu2 sigma2];

fg = FactorGraph();
fg.Solver = 'Gaussian';
----

We have not yet added a factor, so the real variables indicated by a are not yet associated with the fg FactorGraph.

.Linear Factors
.Add

As mentioned previously, the add function is implemented analytically. The following code demonstrates how to implement a factor graph that imposes the constraint that a=b+c

----
a = Real();
b = Real();
c = Real();
 
mus = [8 10 -1];
sigmas = [1 2 3];

a.Input = [mus(1) sigmas(1)];
b.Input = [mus(2) sigmas(2)];
c.Input = [mus(3) sigmas(3)];

fg = FactorGraph();
fg.Solver = 'Gaussian';

f = fg.addFactor(@add,a,b,c);

fg.solve();
----

Note that the @add syntax in MATLAB implies that add is a method and @add is a function handle. Users do not have to define an add function or worry about an existing add function since {swname} matches the function name to its custom add factor.

.Multiply by Constant

The constmult factor adds a constraint that a=bc or a=cb. The product should be the left most argument to the addFactor call.

----
fg = FactorGraph();
a = Real();
b = Real();
c = 5;

fg.Solver = 'Gaussian';
fg.addFactor(@constmult,a,b,c);
a.Input = [10 1];
fg.solve();

assertEqual(b.Belief,[10/5; 1/5]);
     
a.Input = [0 Inf];
b.Input = [10, 1];
   
fg.solve();
    
assertEqual(a.Belief,[10*5; 1*5]);
----

.Linear Factor

Assuming you want to specify the following constraint:

[latex]
\[
 \sum_i x_i c_i = total
\]

where c is a vector of constants and x is a vector of variables and total is a constant, you can use the Gaussian solver linear factor:

----
    fg = FactorGraph();
    fg.Solver = 'Gaussian';

    x1 = Real();
    x2 = Real();
    x3 = Real();
    consts = [1 2 3];
    total = 6;
    fg.addFactor(@linear,x1,x2,x3,consts,total);
----

.General Factors

The Gaussian Solver provides a mechanism to support general factors that cannot calculate messages analytically and require sampling methods instead. The user must provide several methods:

* For each edge of the factor:
** A (first) function that is passed sample values of all of the *other* edges, and returns a value between 0 and 1.
*** This function represents the integral or sum of the factor function over the variable associated with this edge (scaled to be between 0 and 1). For example, if the factor is F(x,y,z), then for variable z, this would return Hz(x,y)/max(Hz), where Hz(x,y) = int_z F(x,y,z) dz, and Max(Hz) is the maximum value of Hz(x,y) over all values of x and y. For output variable y, it would return a similar function, but integrated over y instead of z; and for output variable x, integrated over x. If a particular variable is discrete, this sum can be done in software. For real variables, the user would be responsible for this integration (this is why we might need other methods--sometimes an integral would be too difficult to do by hand).
* A (second) function that is passed sample values of all of the *other* edges, and returns a sample from the conditional probability of the variable associated with this edge given a value for all other edges. It is up to the user to write the code to sample from this distribution.
** For example, if the factor is F(x,y,z), then for variable z, this would return Z ~ p(z|x,y) = F(x,y,z) / Hz(x,y), where Hz(x,y) is as defined above. In some cases, such as certain delta-factors that are single-valued in a given direction, p(z|x,y) may be deterministic in which case no sampling is required. In other cases, such as delta-factors that are multi-valued in a given direction, the sampling is uniform among a small set of values. In other cases, it may be more difficult, and at some point we might need to provide some additional utilities to facilitate generating samples.

The {swname} Gaussian Solver uses those methods as follows:

* For some number of samples
** Until a sample is accepted
*** For each input message (mean/variance)
**** Generate a new sample using the specified mean/variance
*** Call the first user-method for the given output edge, which returns a value H (the function that returns Hz(x,y)/max(Hz) in the example above)
*** Choose a random number U from 0 to 1
*** If U < H, then accept the new set of input edge sample values, and break
*** Otherwise, continue
** Call the second user-method for the given output edge using the accepted input values are arguments, which returns a sample Z (the function that returns Z ~ p(z|x,y) in the example above)
** Add the sample Z to a list of output sample values
* For all output sample values
** Calculate the sample mean
** Calculate the sample variance
** Set the output message to these values

.The Factor

Users who wish to create their own FactorFunctions to be used with the Gaussian solver must create a class that extends the GaussianFactorFunction provided by {swname}. The user must provide implementations for the acceptanceRatio method and the generateSample method.

----
import com.lyricsemi.dimple.solvers.gaussian.GaussianFactorFunction;

public class GaussianAddFactorFunction extends GaussianFactorFunction
{

    public GaussianAddFactorFunction() 
    {
        super("GaussianAdd");
    }

    @Override
    public double acceptanceRatio(int portIndex, Object... inputs) 
    {
        return 1;
    }

    @Override
    public Object generateSample(int portIndex, Object... inputs) 
    {
        if (portIndex == 0)
        {
	    double sum = 0;
	    for (int i = 0; i < inputs.length; i++)
            {
                sum += (Double)inputs[i];
            }
            return sum;
         }
         else
         {
             double sum = (Double)inputs[0];
             for (int i = 1; i < inputs.length; i++)
             {
                 sum -= (Double)inputs[i];
             }
             return sum;
         }
    }
}
----

This class is only useful for demonstration since it simply provides a less precise method for calculating an @add factor. Note that the acceptanceRatio method always returns 1 in this instance.

The portIndex indicates which edge of the Factor is being updated (the index of the factor's argument). The inputs array specifies the samples that were generated from all of the edges other than the output edge.

.Example

The following example does the following:

* Create a Factor Graph and Variable
* Specify how many samples to generate before calculating an outgoing message.
* Specify a random seed (for repeatability of testing)
* For each edge
** Specify the inputs
** Add the factor
** Solve
** Get the beliefs
** Remove the factor and replace with the @add factor
** Solve
** Get the beliefs
** Compare the analytic to the sampled result.

----
v = Real(3,1);

fg = FactorGraph();
fg.Solver = 'Gaussian';
fg.Solver.setNumSamples(100000);
fg.Solver.setSeed(0);

%%%%%%%%%%%%%%%%%%%%%%%%
%Test add
inputs = [9 2; ...
          3 2; ...
          6 2];

for i = 1:3
   tmpinputs = inputs;
    
   tmpinputs(i,:) = [0 Inf];
   
   v(1).Input = tmpinputs(1,:);
   v(2).Input = tmpinputs(2,:);
   v(3).Input = tmpinputs(3,:);

   f = fg.addFactor(com.lyricsemi.dimple.test.GaussianAddFactorFunction(),v(1),v(2),v(3));

   fg.solve();

   actualBelief = v(i).Belief;
    
   fg.removeFactor(f);
    
   f = fg.addFactor(@add,v(1),v(2),v(3));

   fg.solve();

   expectedBelief = v(i).Belief;
    
   fg.removeFactor(f);
    
   diff = abs(actualBelief - expectedBelief);
   assertTrue(all(diff < .02));

end
----

Users can specify different numbers of samples to be accrued for each factor.

----
f1.setNumSamples(x);
f2.setNumSamples(y);
----

where f1 and f2 are objects returned from an addFactor call.

.MaxNumTries

If the user defined FactorFunction provides a low acceptance ratio, it's conceivable a Factor computation might never terminate. The user can specify a maximum number of attempts to be made before throwing an exception:

----
fg.Solver.setMaxNumTries(1e6);
----

.Multivariate Gaussians

The {swname} Gaussian solver provides some support for multivariate Gaussian variables and factors.

.Variables

The following code demonstrates the creation and use of a multivariate Gaussian.

----
rj = RealJoint(2);
means = [2 3]’;
covar = [1 0;
         0 1];
rj.Input = MultivariateMsg(means,covar);
rj.Belief.Means
rj.Belief.Covariance
----

Users must create RealJoint variables.  The first argument of the constructor specifies the number of variables in the multivariate Gaussian.  The Gaussian solver expects users to specify a MultivariateMsg type as input to the variable.  This message type takes a mean vector and covariance matrix as arguments.  Beliefs return MultivariateMsg types.

.Factors

The Multivariate Gaussian solver supports a matrix multiplication and addition factor.  The following code snippet is taken from the demos/17_KalmanFilter/run.m file.

----
%F is the state transition model.  (Given current state, what's the next 
%state?)
%new position is a function of old position, velocity, acceleration
%New velocity is old velocity + acceleration
%new acceleration is a function of velocity, friction, and force. 
 
F = [1  0   dt          0           dt^2/2  0       0       0;
    0  1   0           dt          0       dt^2/2  0       0;
    0  0   1           0           dt/2    0       0       0;
    0  0   0           1           0       dt/2    0       0;
    0  0   -gamma/m    0           0       0       Fw(1)   0;
    0  0   0           -gamma/m    0       0       0       Fw(2);
    0  0   0           0           0       0       1       0
    0  0   0           0           0       0       0       1
    ];
 
%H is the matrix that projects down to the observation.
H = [1 0 0 0 0 0 0 0;
    0 1 0 0 0 0 0 0];


fz = RealJoint(2);
fv = RealJoint(2);
fznonoise = RealJoint(2);
fx = RealJoint(8);
fxnext = RealJoint(8);

nested.addFactor(@constmult,fznonoise,H,fx);
nested.addFactor(@add,fz,fv,fznonoise);
nested.addFactor(@constmult,fxnext,F,fx);
----

.Rolled up graphs and Multivariate Gaussians

Rolled up graphs can be used with Multivariate Gaussians.  This is useful for creating Kalman filters.  The only difference between Multivariate Gaussian rolled up graphs and other rolled up graphs is the data source type.  The following code snippet is taken from the demo/17_KalmanFilter/run.m file:

----
%create the rolled up graph.
fzs = RealJointStream(numel(p0));
fvs = RealJointStream(numel(p0));
fznonoise = RealJointStream(numel(p0));
fxs = RealJointStream(numel(x00));
fg = FactorGraph();
rf = fg.addRepeatedFactor(nested,fxs.getSlice(1),fxs.getSlice(2),...
                     fznonoise.getSlice(1),fvs.getSlice(1),fzs.getSlice(1));
 
%If we set the buffersize to something other than the default of 1, this
%will no longer be a Kalman filter.  Backwards messages will improve the
%guesses.
%rf.BufferSize = 10;
 
%Create data sources.
zDataSource = MultivariateDataSource();
vDataSource = MultivariateDataSource();

%Assign data
the following is in a loop
    zDataSource.add(z,eye(2)*1e-100);
    vDataSource.add(zeros(2,1),R);
end

fzs.DataSource = zDataSource;
fvs.DataSource = vDataSource;
 
%Create arrays to save data.
fgxs = zeros(timesteps,1);
fgys = zeros(timesteps,1);
 
%Step through time and solve the Factor Graph.
for i = 1:timesteps
   fg.solve();
   fgxs(i) = fxs.FirstVar.Belief.Means(1);
   fgys(i) = fxs.FirstVar.Belief.Means(2);
         
   if fg.hasNext()
       fg.advance();
   else
       break;
   end
end
----

Finite Fields
~~~~~~~~~~~~~

Overview
^^^^^^^^^

{swname} supports a special variable type called a FiniteFieldVariable and a few custom factors for these variables. They represent finite fields with N=2n elements. These fields find frequent use in error correcting codes. Because {swname} can describe any discrete distribution, it is possible to handle finite fields simply by describing their combo tables. However, the native FiniteFieldVariable type is much more efficient. In particular, variable addition and multiplication, which naively require O(N3) operations, are calculated in only O(Nlog(N)) operations. We feel the syntax is also simpler.

Finite Fields Without Optimizations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As we mentioned previously, a user can construct (non-optimized) finite fields from scratch.

First we create a domain for our variables using the MATLAB gf function (for Galois Field).

----
m = 3; 
numElements = 2^m;
domain = 0:numElements-1;

tmp = gf(domain,m); 
real_domain = cell(length(tmp),1);
for i = 1:length(tmp)
  real_domain{i} = tmp(i); 
end
----

Next we create a bunch of variables with that domain.

----
x_slow = Discrete(real_domain);
y_slow = Discrete(real_domain); 
z_slow = Discrete(real_domain);
----

Now we create our graph and add the addition constraint.

----
fg_slow = FactorGraph();

add = @(x,y,z) x+y==z;
fg_slow.addFactor(@addDelta,x_slow,y_slow,z_slow);
----

This code runs in O(N^3^) time since it tries all combinations of x,y, and z.
Next we set some inputs.

----
x_input = rand(size(x_slow.Domain));
y_input = rand(size(y_slow.Domain));

x_slow.Input = x_input;
y_slow.Input = y_input;
----

Finally we set number of iterations, solve, and look at beliefs.

----
fg_slow.Solver.setNumIterations(1);

fg_slow.solve();

z_slow.Belief
----

The solver runs in O(N^2^) time since z is determined by x and y, x is determined by z, and y, and y is determined by x and z.

Optimized Finite Field Operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Rather than building finite field elements from scratch, a user can use a build-in variable type and associated set of function nodes. These native variables are much faster, both for programming and algorithmic reasons. All of these operations are supported with the sum product Solver.

.FiniteFieldVariables

{swname} supports a FiniteFieldVariable variable type, which takes a primitive polynomial (to be discussed later) and dimensions of the matrix as constructor arguments:

----
v = FiniteFieldVariable(prim_poly,3,2);
----

This would create a 3x2 matrix of finite field Variables with the given primitive polynomial.

.Addition

Users can use the following syntax to create an addition factor node with three variables:

----
myFactorGraph.addFactor(@finiteFieldAdd,x,y,z);
----

The @finiteFieldAdd method must have exactly that name for the Custom Factor to be used.

Adding this variable take O(1) time and solving takes O(Nlog(N)) time, where N is the size of the finite field domain.

.Multiplication

Similarly, the following syntax can be used to create a factor node with three variables for multiplication:

----
myFactorGraph.addFactor(@finiteFieldMult,x,y,z);
----

Under the hood this will create one of two custom factors, FiniteFieldConstMult or FiniteFieldMult. The former will be created if x or y is a constant and the latter will be created if neither is a constant. This allows {swname} to optimize belief propagation so that it runs in O(N) for multiplication by constants and O(Nlog(N)) in the more general case.

.NVarFiniteFieldPlus

Suppose we have the finite field equation

[latex]
$ x1+x2+x3+x4=0 $

We can not express that using the finiteFieldAdd function directly, since it accepts only three arguments. However, we can support larger addition constraints by building a tree of these constraints. We do so using the following function:

----
NumVars = 4;
[graph,vars] = getNVarFiniteFieldPlus(prim_poly,NumVars);
----

This function takes a primitive polynomial and the number of variables involved in the constraint and builds up a graph such that 

[latex]
$ x_1+...+x_n = 0 $ 

It returns both the graph and the external variables of the graph. This can be used in one of two ways: setting inputs on the variables and solving the graph directly or using this as a nested sub-graph.

.Projection

Elements of a finite field with base 2 can be represented as polynomials with binary coefficients. Polynomials with binary coefficients can be represented as strings of bits. For instance, x3+x+1 could be represented in binary as 1011. Furthermore, that number can be represented by the (decimal) integer 11. When using finite fields for decoding, we are often taking bit strings and re-interpreting these as strings of finite field elements. We can use the finiteFieldProjection factor to relate n bits to a finite field variable with a domain of size 2n.

The following code shows how to do that:

----
args = cell(n*2,1);
for j = 0:n-1
   args{j*2+1} = j;
   args{j*2+2} = bits(n-j);
end

myFactorGraph.addFactor(@finiteFieldProjection,v,args{:});
----

Primitive Polynomials
^^^^^^^^^^^^^^^^^^^^^^
See Wikipedia for a definition. 

Algorithmics
^^^^^^^^^^^^^

{swname} interprets the domains as integers mapping to bit strings describing the coefficients of polynomials. Internally, the FiniteFieldVariable contains functions to map from this representation to a representation of powers of the primitive polynomial. This operation is known as the discrete log. Similarly {swname} FiniteFieldVariables provide a function to map the powers back to the original representation (i.e. an exponentiation operator).

* The addition code computes x+y by performing a fast Hadamard transform of the distribution of both x and y, pointwise multiplying the transforms, and then performing an inverse fast Hadamard transform.
* The generic multiplication code computes xy by performing a fast Fourier transform on the distribution of the non-zero elements of the distribution, pointwise multiplying the transforms, performing an inverse fast Fourier transform, and then accounting for the zero elements.
* The constant multiplication code computes x by converting the distribution of the non-zero values of x to the discrete log domain (which corresponds to reshuffling the array), adding the discrete log of  modulo N−1 (cyclically shifting the array), and exponentiating (unshuffling the array back to the original representation).  

